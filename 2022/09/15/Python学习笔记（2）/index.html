
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>Python学习笔记（2）基础数据类型 | Albatross&amp;blog</title>
        <meta name="author" content="Albatross">
        <meta name="description" content="">
        <meta name="keywords" content="吃喝玩睡ing">
        <link rel="icon" href="/images/c.jpg">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        
        </script>
        
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
       
    <meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Albatross&blog" type="application/atom+xml">
</head>
    <body>

        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Albatross&blog</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;Albatross&blog</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">archives</div>
                </div>
            </a>
            
            <a href="categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">categories</div>
                </div>
            </a>
            
            <a href="tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
    <canvas
    id="background"
    style="position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:-1"
></canvas>
<script src="/js/background.js"></script>
</nav>


                    </div>
                    <div id="main">
                        
<div class="article">
    <div>
        <h1>Python学习笔记（2）基础数据类型 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/15
        </span>
        
        <span class="category">
            <a href="/categories/语言学习/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                语言学习
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
            </span>
            
            <span class="tag">
                
                <a href="/tags/PYTHON/" style="color: #00a596">
                    PYTHON
                </a>
            </span>
            
        </span>
        
    </div>
    <div class="content" v-pre>
        <p>最近在学py，简单记录一下笔记</p>
<span id="more"></span>
<h2 id="格式化输出"><a class="header-anchor" href="#格式化输出">¶</a>格式化输出</h2>
<p>放置占位符，再把字符串里的占位符与外部的变量做好映射关系</p>
<pre><code class="language-python">name = input(&quot;Name:&quot;) 
age = input(&quot;Age:&quot;) 
job = input(&quot;Job:&quot;) 
hobby = input(&quot;Hobbie:&quot;) 

info = ''' ------------ info of %s ----------- #这里的每个%s就是一个占位符，本行的代表 后面拓号里的 name 
Name : %s #代表 name 
Age  : %s #代表 age  job  : %s #代表 job 
Hobbie: %s #代表 hobbie 
------------- end -----------------
 ''' % (name,name,age,job,hobbie) # 这行的 % 号就是 把前面的字符串 与拓号 后面的 变量 关联起来 

print(info)         
</code></pre>
<p><u>注意空格</u></p>
<p>%s就是代表字符串占位符，除此之外，还有%d, 是数字占位符， 如果把上面的age后面的换成%d，就代表你必须只能输入数字啦, 这时对应的数据必须是int类型. 否则程序会报错使用时,需要进行类型转换.</p>
<pre><code class="language-python">int(str)   # 字符串转换成int 
str(int)   # int转换成字符串      
</code></pre>
<blockquote>
<p>在字符串中如果使用了%s这样的占位符. 那么所有的%都将变成占位符需要使用%%来表示字符串中的%</p>
</blockquote>
<p>python3.5以后可以使用f来格式化字符串.</p>
<p>语法 : <code>f&quot;&#123;变量&#125;&quot;</code></p>
<pre><code class="language-python">name = &quot;sylar&quot; 
print(f&quot;&#123;name&#125;真是一个...&quot;)         
</code></pre>
<p>​</p>
<h2 id="基本运算符"><a class="header-anchor" href="#基本运算符">¶</a>基本运算符</h2>
<h4 id="算术运算"><a class="header-anchor" href="#算术运算">¶</a>算术运算</h4>
<p><img src="/images/%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97.png" alt="image-20220915164625454"></p>
<h4 id="比较运算"><a class="header-anchor" href="#比较运算">¶</a>比较运算</h4>
<p><img src="/images/%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97.png" alt="image-20220915164937061"></p>
<h4 id="赋值运算"><a class="header-anchor" href="#赋值运算">¶</a>赋值运算</h4>
<p><img src="/images/%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97.png" alt="image-20220915165015281"></p>
<h4 id="逻辑运算"><a class="header-anchor" href="#逻辑运算">¶</a>逻辑运算</h4>
<p><img src="/images/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97.png" alt="image-20220915165046443"></p>
<p>and 并且 and左右两端同时为真，结果才为真</p>
<p>or 或者 两端有一个为真结果为真</p>
<p>not 非 非真即假，非假即真</p>
<p><strong>逻辑运算的运算顺序: () &gt; not &gt; and &gt; or</strong></p>
<h4 id="成员运算"><a class="header-anchor" href="#成员运算">¶</a>成员运算</h4>
<p><code>xx in xxx</code> 	表示xx是否不在xxx中出现</p>
<p><code>xx not...in xxx</code>   表示xx是否不在xxx中出现</p>
<h2 id="编码初识以及bytes"><a class="header-anchor" href="#编码初识以及bytes">¶</a>编码初识以及bytes</h2>
<ol>
<li>ascii : 8bit, 主要存放的是英文, 数字,  特殊符号</li>
<li>gbk: 16bit, 主要存放中文和亚洲字符. 兼容ascii</li>
<li>unicode: 16bit和32bit两个版本. 平时我们用的是16bit这个版本. 全世界所有国家的文字信息. 缺点: 浪费空间(传输和存储)</li>
<li>utf-8 : 可变长度unicode, 英文: 8bit, 欧洲文字: 16bit, 中文24bit. 一般数据传输和存储的时候使用.</li>
<li>以上所有编码必须兼容ascii .</li>
</ol>
<p>内存中使用的是unicode ，一个/x就是一个字节，一个汉字三个字节</p>
<p>gbk中，一个汉字两个字节</p>
<p><u>编码用encode()  解码用decode()</u></p>
<p>不同的编码之间是不能进行转换的，若想转换，可以先解码再编码</p>
<p>一个字节8个0和1</p>
<h2 id="基础数据类型bool"><a class="header-anchor" href="#基础数据类型bool">¶</a>基础数据类型bool</h2>
<p>所有表示空的东西都是False</p>
<p>基本数据类型之间的转化, 想变成谁, 就用谁把数据括起来</p>
<h2 id="基础数据类型str"><a class="header-anchor" href="#基础数据类型str">¶</a>基础数据类型str</h2>
<p>把字符连成串. 在python中用’, &quot;, ‘’', “”&quot;引起来的内容被称为字符串.</p>
<p>字符串: 把多个字符连成串</p>
<h4 id="字符串索引和切片"><a class="header-anchor" href="#字符串索引和切片">¶</a>字符串索引和切片</h4>
<p>索引从0开始</p>
<p>切片:</p>
<p>s[start: end: step]</p>
<p>start: 起始位置</p>
<p>end: 结束位置, 取不到</p>
<p>step: 步长（步长如果是负数，从右往左取数字）.</p>
<h4 id="常用API"><a class="header-anchor" href="#常用API">¶</a>常用API</h4>
<ol>
<li>
<p>upper(), 把字符串中所有的字母都变成大写. 主要使用在忽略大小写的时候用</p>
</li>
<li>
<p>strip(), 默认去掉左右两端的空白, 包括\n, \t, 空格.</p>
</li>
<li>
<p>replace(), 字符串替换</p>
</li>
<li>
<p>split(),  字符串切割. 得到字符串列表</p>
</li>
<li>
<p>join(),  把列表重新组合成字符串</p>
<pre><code class="language-python">lst = ['周杰伦', '王力宏', '麻花藤'] 
s = &quot;_&quot;.join(lst) 
print(s)  # 周杰伦_王力宏_麻花藤           
</code></pre>
</li>
<li>
<p>startswith(),  判断是否以xxxx开头</p>
</li>
<li>
<p>endwith(),判断是否以xx结尾</p>
</li>
<li>
<p>find(), 查找xxxx</p>
</li>
<li>
<p>index()，求索引位置，如果找不到系统会报错</p>
</li>
<li>
<p>count(), 数数, 查看xxx出现的次数</p>
</li>
<li>
<p>isdigit(), 判断该字符串是否是由数字组成</p>
</li>
<li>
<p>len(), 字符串长度, 它是一个内置函数, 直接len(数据)即可</p>
</li>
<li>
<p>capitalize(),首字母变成大写</p>
</li>
<li>
<p>dir(),能查看这个数据类型能执行哪些操作</p>
</li>
</ol>
<pre><code class="language-python">for 变量 in 可迭代对象（不能放数字在这里）:

循环体
</code></pre>
<h4 id="关于in"><a class="header-anchor" href="#关于in">¶</a>关于in</h4>
<pre><code class="language-python"> '''   in有两种用法:     
	1. 在for中. 是把每一个元素获取到赋值给前面的变量.
    2. 不在for中. 判断xxx是否出现在str中. 
''' 
print('VUE' in s19)      
</code></pre>
<h4 id="字符串的格式化输出"><a class="header-anchor" href="#字符串的格式化输出">¶</a>字符串的格式化输出</h4>
<pre><code class="language-python">name = 'Jay'
age = 8

s1 = &quot;我叫%s,我今年%d岁了&quot; % (name,age)
print(s1)

s2 = f&quot;我叫&#123;name&#125;,我今年&#123;age&#125;岁了&quot;
print(s2)

#按照位置格式化
s3 = &quot;我叫&#123;&#125;,我今年&#123;&#125;岁了&quot;.format(name,age)
print(s3)

#按照函数中参数顺序分别填入对应相应的参数，从0开始，不得越界
s4 = &quot;我叫&#123;1&#125;,我今年&#123;0&#125;岁了&quot; .format(name,age)
print(s4)

s5 = &quot;我叫&#123;aname&#125;,我今年&#123;aage&#125;岁了&quot; .format(aname=name,aage=age)
print(s5)
</code></pre>
<p><u>字符串是不可变的对象, 所以任何操作对原字符串是不会有任何影响的</u></p>
<h2 id="基础数据类型list"><a class="header-anchor" href="#基础数据类型list">¶</a>基础数据类型list</h2>
<p>列表是python的基础数据类型之一 ,其他编程语言也有类似的数据类型. 比如JS中的数组, java中的数组等等. 它是以[ ]括起来, 每个元素用’ , '隔开而且可以存放各种数据类型.</p>
<p>列表相比于字符串. 不仅可以存放不同的数据类型. 而且可以存放大量的数据. 32位python可以存放: 536870912个元素, 64位可以存放: 1152921504606846975个元素.而且列表是有序的(按照你保存的顺序),有索引, 可以切片方便取值.</p>
<h4 id="索引和切片"><a class="header-anchor" href="#索引和切片">¶</a>索引和切片</h4>
<p>和字符串中索引和切片操作基本相同，不同的是列表中的数据类型是list</p>
<p><u>列表是一个可变的数据类型</u></p>
<h4 id="列表查常用操作"><a class="header-anchor" href="#列表查常用操作">¶</a>列表查常用操作</h4>
<h5 id="增加"><a class="header-anchor" href="#增加">¶</a>增加</h5>
<p>注意, list和str是不一样的. list可以发生改变. 所以直接就在原来的对象上进行了操作</p>
<p>append的效率高于insert</p>
<pre><code class="language-python">lst = [&quot;麻花藤&quot;, &quot;林俊杰&quot;, &quot;周润发&quot;, &quot;周芷若&quot;] 
print(lst) 
lst.append(&quot;wusir&quot;) 
print(lst) 
lst = [] 
while True:   
    content = input(&quot;请输入你要录入的员工信息, 输入Q退出:&quot;)   
    if content.upper() == 'Q':     
        break   
    lst.append(content) 
print(lst) 

lst = [&quot;麻花藤&quot;, &quot;张德忠&quot;, &quot;孔德福&quot;] 
lst.insert(1, &quot;刘德华&quot;)  # 在1的位置插入刘德华. 原来的元素向后移动一位 
print(lst) 

# 迭代添加 
lst = [&quot;王志文&quot;, &quot;张一山&quot;, &quot;苦海无涯&quot;] 
lst.extend([&quot;麻花藤&quot;, &quot;麻花不疼&quot;]) 
print(lst)          
</code></pre>
<h5 id="删除"><a class="header-anchor" href="#删除">¶</a>删除</h5>
<p>pop, remove, clear, del</p>
<pre><code class="language-python">lst = [&quot;麻花藤&quot;, &quot;王剑林&quot;, &quot;李嘉诚&quot;, &quot;王富贵&quot;] 
print(lst) 
deleted = lst.pop()     # 默认删除最后一个 
print(&quot;被删除的&quot;, deleted) 
print(lst) 

el = lst.pop(2)   # 删除2号元素 
print(el) 
print(lst) 

lst.remove(&quot;麻花藤&quot;)  # 删除指定元素 
print(lst) # lst.remove(&quot;哈哈&quot;)  # 删除不存在的元素会报错 # print(lst) 

lst.clear()   # 清空list 
print(lst) 

# 切片删除 
del lst[1:3] 
print(lst)   
</code></pre>
<h5 id="修改"><a class="header-anchor" href="#修改">¶</a>修改</h5>
<p>索引切片修改</p>
<pre><code class="language-python"># 修改
lst = [&quot;得儿得儿&quot;, &quot;太牛&quot;, &quot;胡辣汤&quot;, &quot;王者荣耀&quot;, &quot;科科&quot;] 
lst[1] = &quot;太污&quot;  # 把1号元素修改成太污 
print(lst) 

lst[1:4:3] = [&quot;麻花藤&quot;, &quot;哇靠&quot;]   # 切片修改也OK. 如果步长不是1, 要注意. 元素的个数 
print(lst) 

lst[1:4] = [&quot;压了个嘿嘿&quot;] # 如果切片没有步长或者步长是1. 则不用关心个数 
print(lst)    
</code></pre>
<h5 id="查询"><a class="header-anchor" href="#查询">¶</a>查询</h5>
<p>列表是一个可迭代对象, 所以可以进行for循环</p>
<pre><code class="language-python">for el in lst:   
    print(el)     
</code></pre>
<h5 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h5>
<pre><code class="language-python">lst = [&quot;小白&quot;, &quot;小黑&quot;, &quot;腾哥&quot;, &quot;马总&quot;, &quot;日天&quot;, &quot;小白&quot;] 
c = lst.count(&quot;小白&quot;)   # 查询太白出现的次数 
print(c) 

lst = [1, 11, 22, 2] 
lst.sort()     # 排序. 默认升序 
print(lst) 

lst.sort(reverse=True) # 降序 
print(lst) 

lst = [&quot;小白&quot;, &quot;小黑&quot;, &quot;腾哥&quot;, &quot;马总&quot;, &quot;日天&quot;, &quot;白天&quot;] 
print(lst) 

lst.reverse() #翻转
print(lst) 

l = len(lst)  # 列表的长度 
print(l) 

#rang（让for循环去数数,顾头不顾尾）
for num in range(10):
    print(num)	#输出0,1,...10

for num in range(10, 1, -2):    # 反着来, 和切片一样
    print(num)
    
#range最大的作用是可以循环出列表中每一个元素的索引
lst = [&quot;周杰伦&quot;, &quot;马虎疼&quot;, &quot;疼不疼&quot;]
for i in range(len(lst)):
    print(i, lst[i])
</code></pre>
<h4 id="列表的嵌套"><a class="header-anchor" href="#列表的嵌套">¶</a>列表的嵌套</h4>
<pre><code class="language-python">lst = [1, &quot;小白&quot;, &quot;小黑黑&quot;, [&quot;马虎疼&quot;, [&quot;可口可乐&quot;], &quot;王剑林&quot;], 'kounijiwa'] 

# 找到小白和小黑黑 
print(lst[1:3]) 

# 找到小白的白字 
print(lst[1][1]) 

# 将kounijiwa拿到. 然后首字母大写. 再扔回去 
s = lst[4] s = s.capitalize() 
lst[4] = s print(lst) # 简写 lst[4] = lst[4].capitalize() 
print(lst) 

# 把马虎疼换成马化疼 
lst[3][0] = lst[3][0].replace(&quot;虎&quot;, &quot;化&quot;) 
#lst[3][0].replace(&quot;虎&quot;, &quot;化&quot;) 产生一个新的字符串，要将字符串替换到原来的位置
print(lst[3][0]) 

lst[3][1].append(&quot;雪碧&quot;) 
print(lst)     
</code></pre>
<h4 id=""><a class="header-anchor" href="#">¶</a></h4>
<h2 id="基础数据类型tuple"><a class="header-anchor" href="#基础数据类型tuple">¶</a>基础数据类型tuple</h2>
<p>只读列表，元组也是python的基本数据类型之一, 用小括号括起来, 里面可以放任何数据类型的数据,  查询可以. 循环也可以. 切片也可以. 但就是不能改.</p>
<pre><code class="language-python">tu = (1, &quot;太白&quot;, &quot;李白&quot;, &quot;太黑&quot;, &quot;怎么黑&quot;) 
print(tu)

print(tu[2:5]) # 切片之后还是元组 

# for循环遍历元组 
for el in tu:   
	print(el) 
	
# 尝试修改元组 
# tu[1] = &quot;马虎疼&quot;  # 报错 'tuple' object does not support item assignment 

tu = (1, &quot;哈哈&quot;, [], &quot;呵呵&quot;) 
# tu[2] = [&quot;fdsaf&quot;]   这么改不行 

tu[2].append(&quot;麻花藤&quot;)   # 可以改了. 没报错 
print(tu)     
</code></pre>
<p><strong><u>这里元组的不可变的意思是子元素不可变，元组内存的指向不可变. 而子元素内部的子元素是可以变, 这取决于子元素是否是可变对象.</u></strong></p>
<p><u>元组中如果只有一个元素. 一定要添加一个逗号, 否则就不是元组</u></p>
<pre><code class="language-python">tu = (1,) 
print(type(tu))     
</code></pre>
<p>​</p>
<h2 id="基础数据类型dict"><a class="header-anchor" href="#基础数据类型dict">¶</a>基础数据类型dict</h2>
<p>字典(<code>dict</code>)是python中唯一的一个映射类型.他是以{ }括起来的键值对组成. 在<code>dict</code>中key是唯一的. 在保存的时候, 根据key来计算出一个内存地址. 然后将<code>key:value</code>保存在这个地址中. 这种算法被称为hash算法, 所以, 切记, 在<code>dict</code>中存储的<code>key:value</code>中的key’必须是可hash的, 如果你搞不懂什么是可哈希, 暂时可以这样记, 可以改变的都是不可哈希的, 那么可哈希就意味着不可变. 这个是为了能准确的计算内存地址而规定的.</p>
<p>已知的可哈希(不可变)的数据类型: int, str, tuple, bool</p>
<p>不可哈希(可变)的数据类型: list, dict, set</p>
<p>语法 :</p>
<p>{key1: value1, key2: value2…}</p>
<blockquote>
<p>注意:</p>
<p>key必须是不可变(可哈希)的. value没有要求.可以保存任意类型的数据</p>
<p>dict保存的数据不是按照我们添加进去的顺序保存的. 是按照hash表的顺序保存的. 而hash表不是连续的. 所以不能进行切片工作. 它只能通过key来获取dict中的数据</p>
</blockquote>
<h4 id="字典增删改查和其他操作"><a class="header-anchor" href="#字典增删改查和其他操作">¶</a>字典增删改查和其他操作</h4>
<p>增加</p>
<pre><code class="language-python">dic = &#123;&#125;
dic['name'] = '周润发'     # 如果dict中没有出现这个key, 就会新增一个key-value的组合进dict
print(dic)

# 如果dict中没有出现过这个key-value,key必须是不存在的. 可以通过setdefault设置默认值
dic.setdefault('李嘉诚')   # 也可以往里面设置值.
dic.setdefault(&quot;李嘉诚&quot;, &quot;房地产&quot;)    # 如果dict中已经存在了. 那么setdefault将不会起作用

print(dic)
</code></pre>
<p>删除(参考列表，没有remove)</p>
<pre><code class="language-python">ret = dic.pop(&quot;jay&quot;)	#pop中加上key
print(ret)

del dic[&quot;jay&quot;]
print(dic)

# 清空字典中的所有内容
dic.clear()
</code></pre>
<p>修改</p>
<pre><code class="language-python">dic = &#123;&quot;id&quot;: 123, &quot;name&quot;: 'sylar', &quot;age&quot;: 18&#125;
dic1 = &#123;&quot;id&quot;: 456, &quot;name&quot;: &quot;麻花藤&quot;, &quot;ok&quot;: &quot;wtf&quot;&#125;
dic.update(dic1)    # 把dic1中的内容更新到dic中. 如果key重名. 则修改替换. 如果不存在key, 则新增.
print(dic)
</code></pre>
<p>查询（根据是否确定该key存在选择使用）</p>
<pre><code class="language-python">print(dic['name'])	 # 不存在 报错
print(dic.get(&quot;sylar&quot;))      # 不存在 返回None
print(dic.get(&quot;sylar&quot;, &quot;牛B&quot;))   # 牛B
#setdefault 在执行完新增流程后，会根据key查询value
print(dic.setdefault(&quot;sylar&quot;))   
</code></pre>
<p>循环</p>
<pre><code class="language-python">dic = &#123;&quot;id&quot;: 123, &quot;name&quot;: 'sylar', &quot;age&quot;: 18, &quot;ok&quot;: &quot;科比&quot;&#125;

#第一种
for k in dic:
    print(k)
    
# dict.keys(['id', 'name', 'age', 'ok']) 不用管它是什么.当成list来用就行
for key in dic.keys():
    print(key)

# dict.values([123, 'sylar', 18, '科比']) 当list来用
for value in dic.values():
    print(value)

# dict_items([('id', 123), ('name', 'sylar'), ('age', 18), ('ok', '科比')]) 这个东西也是list. 只不过list中装的是tuple
for key, value in dic.items(): #解构
    print(key, value)

# 解构
a = 1, 2
print(a) #类型是元组（1,2）

(c, d) = 3, 4
print(c, d)	#分别输出3,4 类型都是int

# 解构的时候注意数量必须匹配 错误写法 最多两个元素
e, f = [1, 2, 3]    
print(e, f)
</code></pre>
<h4 id="字典的嵌套"><a class="header-anchor" href="#字典的嵌套">¶</a>字典的嵌套</h4>
<pre><code class="language-python">dic1 = &#123;
    &quot;name&quot;: &quot;汪峰&quot;,
    &quot;age&quot;: 18,
    &quot;wife&quot;: &#123;
        &quot;name&quot;: '章子怡',
        &quot;age&quot;: 28
    &#125;,
    &quot;children&quot;: ['第一个毛孩子', '第二个毛孩子'],
    &quot;desc&quot;: '峰哥不会告我吧. 没关系. 我想上头条的'
&#125;

print(dic1.get(&quot;wife&quot;).get(&quot;name&quot;))
print(dic1.get(&quot;children&quot;)[1])
</code></pre>
<h2 id="基本数据类型Set"><a class="header-anchor" href="#基本数据类型Set">¶</a>基本数据类型Set</h2>
<p>set集合是python的一个基本数据类型. 一般不是很常用. set中的元素是不重复的.无序的.里面的元素必须是可hash的(int, str, tuple,bool), 我们可以这样来记. set就是<code>dict</code>类型的数据但是不保存value, 只保存key. set也用{}表示</p>
<p><code>add</code> 增加</p>
<p><code>remove</code>修改 先把要修改的内容删除，然后新增一个新的</p>
<p>最主要的操作: 去重复, 交,并,差</p>
<pre><code class="language-python">s1 = &#123;&quot;刘能&quot;, &quot;赵四&quot;, &quot;皮长山&quot;&#125;
s2 = &#123;&quot;刘科长&quot;, &quot;冯乡长&quot;, &quot;皮长山&quot;&#125;

# 交集
# 两个集合中的共有元素
print(s1 &amp; s2)  # &#123;'皮长山'&#125;
print(s1.intersection(s2))  # &#123;'皮长山'&#125;

# 并集
print(s1 | s2)  # &#123;'刘科长', '冯乡长', '赵四', '皮长山', '刘能'&#125;
print(s1.union(s2))     # &#123;'刘科长', '冯乡长', '赵四', '皮长山', '刘能'&#125;

# 差集
print(s1 - s2)  # &#123;'赵四', '刘能'&#125; 得到第一个中单独存在的
print(s1.difference(s2))     # &#123;'赵四', '刘能'&#125;
</code></pre>
<h2 id="深浅copy"><a class="header-anchor" href="#深浅copy">¶</a>深浅copy</h2>
<pre><code class="language-python">lst1 = [&quot;金毛狮王&quot;, &quot;紫衫龙王&quot;, &quot;白眉鹰王&quot;, &quot;青翼蝠王&quot;]
#并没有产生新的对象 而是把原来的内存地址 赋给list2
lst2 = lst1
print(lst1)
print(lst2)

lst1.append(&quot;杨逍&quot;)
print(lst1)
print(lst2)

结果:
['金毛狮王', '紫衫龙王', '白眉鹰王', '青翼蝠王', '杨逍']
['金毛狮王', '紫衫龙王', '白眉鹰王', '青翼蝠王', '杨逍']

#可以通过 id(list1) 来查看list1的地址

dic1 = &#123;&quot;id&quot;: 123, &quot;name&quot;: &quot;谢逊&quot;&#125;
dic2 = dic1
print(dic1)  # &#123;'id': 123, 'name': '谢逊'&#125;
print(dic2)  # &#123;'id': 123, 'name': '谢逊'&#125;

dic1['name'] = &quot;范瑶&quot;
print(dic1)  # &#123;'id': 123, 'name': '范瑶'&#125;
print(dic2)  # &#123;'id': 123, 'name': '范瑶'&#125;
</code></pre>
<h4 id="浅拷贝"><a class="header-anchor" href="#浅拷贝">¶</a>浅拷贝</h4>
<pre><code class="language-python">lst1 = [&quot;何炅&quot;, &quot;杜海涛&quot;,&quot;周渝民&quot;]
lst2 = lst1.copy()
lst1.append(&quot;李嘉诚&quot;)
print(lst1)
print(lst2)
print(id(lst1), id(lst2))

结果: 
两个lst完全不一样. 内存地址和内容也不一样. 发现实现了内存的拷贝

lst1 = [&quot;何炅&quot;, &quot;杜海涛&quot;,&quot;周渝民&quot;, [&quot;麻花藤&quot;, &quot;马芸&quot;, &quot;周笔畅&quot;]]
lst2 = lst1.copy()
lst1[3].append(&quot;无敌是多磨寂寞&quot;)
print(lst1)
print(lst2)
print(id(lst1[3]), id(lst2[3]))

结果: 
['何炅', '杜海涛', '周渝民', ['麻花藤', '马芸', '周笔畅', '无敌是多磨寂寞']]
['何炅', '杜海涛', '周渝民', ['麻花藤', '马芸', '周笔畅', '无敌是多磨寂寞']]
4417248328 4417248328
</code></pre>
<p>只会拷贝第一层. 第二层的内容不会拷贝，还是指向原地址. 所以被称为浅拷贝</p>
<h4 id="深拷贝"><a class="header-anchor" href="#深拷贝">¶</a>深拷贝</h4>
<p>必须使用copy模块</p>
<pre><code class="language-python">import copy

lst1 = [&quot;何炅&quot;, &quot;杜海涛&quot;,&quot;周渝民&quot;, [&quot;麻花藤&quot;, &quot;马芸&quot;, &quot;周笔畅&quot;]]
lst2 = copy.deepcopy(lst1)
lst1[3].append(&quot;无敌是多磨寂寞&quot;)
print(lst1)
print(lst2)
print(id(lst1[3]), id(lst2[3]))

结果:
['何炅', '杜海涛', '周渝民', ['麻花藤', '马芸', '周笔畅', '无敌是多磨寂寞']]
['何炅', '杜海涛', '周渝民', ['麻花藤', '马芸', '周笔畅']]
4447221448 4447233800
</code></pre>
<p>深度拷贝. 把元素内部的元素完全进行拷贝复制. 不会产生一个改变另一个跟着改变的问题</p>
<h2 id="知识点补充"><a class="header-anchor" href="#知识点补充">¶</a>知识点补充</h2>
<h4 id="列表和字典循环的时候不能删除"><a class="header-anchor" href="#列表和字典循环的时候不能删除">¶</a>列表和字典循环的时候不能删除</h4>
<p>python中的列表和字典在循环的时候. 不能删除自身中的元素. 列表虽然不报错，但是删不干净.  对于字典, 直接报错. 不让删. 解决方案都一样, 把要删除的内容保存在一个新列表中, 循环新列表, 删除老列表.</p>
<p>每次remove后，后面的元素都会向前挪，但是指针位置还是不变的，导致前挪动的元素，如果符合条件，就不会被删除</p>
<pre><code class="language-python">lst = [&quot;张无忌&quot;, &quot;张翠山&quot;, &quot;灭绝师太&quot;, &quot;胡辣汤&quot;]
new_lst = []
for name in lst:
    if name.startswith(&quot;张&quot;):
        new_lst.append(name)
#法一        
for name in new_lst:
    lst.remove(name)
#法二 新产生的字符串与原字符串指向同一地址
for name in lst[:]:
    if name.startswith('张'):
        lst.remove(name)
        
print(lst) # [&quot;灭绝师太&quot;, &quot;胡辣汤&quot;] 
</code></pre>
<p>字典操作与列表类似，可以选择存储keys</p>
<h4 id="is和-的区别"><a class="header-anchor" href="#is和-的区别">¶</a>is和==的区别</h4>
<p>== 判断的是内容. ==&gt;  两个人长的是不是一样?</p>
<p>is   判断的是内存地址.  ==&gt;  两个人是不是同一个人</p>
<p><u>此结论不适合字符串.</u></p>
<h4 id="while…else"><a class="header-anchor" href="#while…else">¶</a>while…else</h4>
<pre><code class="language-python">while 条件:
    循环体
else: 循环在正常情况跳出之后会执行这里
</code></pre>
<p>如果循环是通过break退出的. 那么while后面的else将不会被执行, 只有在while条件判断是假的时候才会执行这个else</p>
<p><code>pass</code>: <u>不表示任何内容. 为了代码的完整性.  占位而已</u></p>
<h2 id="文件操作"><a class="header-anchor" href="#文件操作">¶</a>文件操作</h2>
<p><code>               f = open(文件, mode=&quot;模式&quot; encoding=&quot;编码&quot;)             </code></p>
<p>f被称为文件句柄，负责操纵你打开的这个文件</p>
<h4 id="模式"><a class="header-anchor" href="#模式">¶</a>模式:</h4>
<p>r: 只读</p>
<p>w: 只写  如果没有文件. 则会创建文件, 如果文件存在. 则将原件中原来的内容删除, 再写入新内容</p>
<pre><code class="language-python">f.write(&quot;\n&quot;) 换行
</code></pre>
<p>a: 追加写    追加写，不会重新创建文件，但是如果文件不存在，可以创建文件</p>
<p>+: 扩展      不是很好用</p>
<p>b: 字节(非文本文件，可理解为二进制文件，不能指定encoding)</p>
<pre><code class="language-python">#s实现文件复制
f1=open(&quot;a/tu.jpg&quot;,mode=&quot;rb&quot;)
f2=open(&quot;c/yu.jpg&quot;,mode=&quot;wb&quot;)
for line in f1:
	f2.write(line)
</code></pre>
<h4 id="读取文件的方法"><a class="header-anchor" href="#读取文件的方法">¶</a>读取文件的方法</h4>
<ol>
<li>read()  将文件中的内容全部读取出来. 弊端: 占内存. 如果文件过大.容易导致内存崩溃</li>
<li>read(n) 读取n个字符. 需要注意的是. 如果再次读取. 那么会在当前位置继续去读而不是从头读, 如果使用的是rb模式. 则读取出来的是n个字节</li>
<li>readline() 一次读取一行数据, 注意: readline()结尾, 注意每次读取出来的数据都会有一个\n 所以呢. 需要我们使用strip()方法来去掉\n或者空格</li>
<li>readlines()将每一行形成一个元素, 放到一个列表中. 将所有的内容都读取出来. 所以也是. 容易出现内存崩溃的问题.不推荐使用</li>
<li>循环读取 读取文件最好的方案</li>
</ol>
<pre><code class="language-python">#另一种写法，可以不用`close` 使用with()自动加入 '\'可以用来表示一行的连接	
    with open() as f1,\
    	 open() as f2:        
		for line in f1:
            f2.write(line)
            print(line.strip())	#去掉换行
			xxxxx
</code></pre>
<p><strong>读取完的文件句柄一定要关闭 <code> f.close()</code>，</strong></p>
<p>​</p>
<h4 id="修改文件"><a class="header-anchor" href="#修改文件">¶</a>修改文件:</h4>
<ol>
<li>创建一个文件副本.</li>
<li>把源文件中的内容读取到内存.</li>
<li>然后在内存中进行修改.</li>
<li>修改之后保存在文件副本中.</li>
<li>把源文件删除</li>
<li>把文件副本更改名称为源文件的名称</li>
</ol>
<pre><code class="language-python"># 文件修改
import os

with open(&quot;小娃娃&quot;, mode=&quot;r&quot;, encoding=&quot;utf-8&quot;) as f1,\
     open(&quot;小娃娃_new&quot;, mode=&quot;w&quot;, encoding=&quot;UTF-8&quot;) as f2:
    content = f1.read()
    new_content = content.replace(&quot;冰糖葫芦&quot;, &quot;大白梨&quot;)
    f2.write(new_content)
os.remove(&quot;小娃娃&quot;)    # 删除源文件
os.rename(&quot;小娃娃_new&quot;, &quot;小娃娃&quot;)     # 重命名新文件
</code></pre>
<p>弊端: 一次将所有内容进行读取. 内存溢出. 解决方案: 一行一行的读取和操作</p>
<pre><code class="language-python">import os

with open(&quot;小娃娃&quot;, mode=&quot;r&quot;, encoding=&quot;utf-8&quot;) as f1,\
     open(&quot;小娃娃_new&quot;, mode=&quot;w&quot;, encoding=&quot;UTF-8&quot;) as f2:
    for line in f1:
        new_line = line.replace(&quot;大白梨&quot;, &quot;冰糖葫芦&quot;)
        f2.write(new_line)
os.remove(&quot;小娃娃&quot;)    # 删除源文件
os.rename(&quot;小娃娃_new&quot;, &quot;小娃娃&quot;)     # 重命名新文件
</code></pre>
<p>​</p>

    </div>
    
</div>
                         


<footer id="footer">
    

    <div class="footer-wrap">
        <div>
            © 2022 - 2022 Albatross&amp;blog
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @Albatross
        </div>

        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
    </div>
    <!--这一段是不蒜子的访问量统计代码-->
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
 
    <span id="busuanzi_value_page_pv"><i class="fa fa-spinner"></i></span> Hits   
</footer>


                        
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        
        

    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
    <canvas
        id="background"
        style="position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:-1"
    ></canvas>
    <script src="/js/background.js"></script>
    <div id="cursor"></div>
<script src="/css/cursor.css"></script>
<script src="/js/cursor.js"></script>
</html>