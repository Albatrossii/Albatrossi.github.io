<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Albatross&amp;blog</title>
  
  <subtitle>欢迎来到我的博客~</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-09-24T04:40:01.949Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Albatross</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python学习笔记（2）基础数据类型</title>
    <link href="http://example.com/2022/09/15/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/"/>
    <id>http://example.com/2022/09/15/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</id>
    <published>2022-09-15T08:10:15.811Z</published>
    <updated>2022-09-24T04:40:01.949Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学py，简单记录一下笔记</p><span id="more"></span><h2 id="格式化输出"><a class="header-anchor" href="#格式化输出">¶</a>格式化输出</h2><p>放置占位符，再把字符串里的占位符与外部的变量做好映射关系</p><pre><code class="language-python">name = input(&quot;Name:&quot;) age = input(&quot;Age:&quot;) job = input(&quot;Job:&quot;) hobby = input(&quot;Hobbie:&quot;) info = ''' ------------ info of %s ----------- #这里的每个%s就是一个占位符，本行的代表 后面拓号里的 name Name : %s #代表 name Age  : %s #代表 age  job  : %s #代表 job Hobbie: %s #代表 hobbie ------------- end ----------------- ''' % (name,name,age,job,hobbie) # 这行的 % 号就是 把前面的字符串 与拓号 后面的 变量 关联起来 print(info)         </code></pre><p><u>注意空格</u></p><p>%s就是代表字符串占位符，除此之外，还有%d, 是数字占位符， 如果把上面的age后面的换成%d，就代表你必须只能输入数字啦, 这时对应的数据必须是int类型. 否则程序会报错使用时,需要进行类型转换.</p><pre><code class="language-python">int(str)   # 字符串转换成int str(int)   # int转换成字符串      </code></pre><blockquote><p>在字符串中如果使用了%s这样的占位符. 那么所有的%都将变成占位符需要使用%%来表示字符串中的%</p></blockquote><p>python3.5以后可以使用f来格式化字符串.</p><p>语法 : <code>f&quot;&#123;变量&#125;&quot;</code></p><pre><code class="language-python">name = &quot;sylar&quot; print(f&quot;&#123;name&#125;真是一个...&quot;)         </code></pre><p>​</p><h2 id="基本运算符"><a class="header-anchor" href="#基本运算符">¶</a>基本运算符</h2><h4 id="算术运算"><a class="header-anchor" href="#算术运算">¶</a>算术运算</h4><p><img src="/images/%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97.png" alt="image-20220915164625454"></p><h4 id="比较运算"><a class="header-anchor" href="#比较运算">¶</a>比较运算</h4><p><img src="/images/%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97.png" alt="image-20220915164937061"></p><h4 id="赋值运算"><a class="header-anchor" href="#赋值运算">¶</a>赋值运算</h4><p><img src="/images/%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97.png" alt="image-20220915165015281"></p><h4 id="逻辑运算"><a class="header-anchor" href="#逻辑运算">¶</a>逻辑运算</h4><p><img src="/images/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97.png" alt="image-20220915165046443"></p><p>and 并且 and左右两端同时为真，结果才为真</p><p>or 或者 两端有一个为真结果为真</p><p>not 非 非真即假，非假即真</p><p><strong>逻辑运算的运算顺序: () &gt; not &gt; and &gt; or</strong></p><h4 id="成员运算"><a class="header-anchor" href="#成员运算">¶</a>成员运算</h4><p><code>xx in xxx</code> 表示xx是否不在xxx中出现</p><p><code>xx not...in xxx</code>   表示xx是否不在xxx中出现</p><h2 id="编码初识以及bytes"><a class="header-anchor" href="#编码初识以及bytes">¶</a>编码初识以及bytes</h2><ol><li>ascii : 8bit, 主要存放的是英文, 数字,  特殊符号</li><li>gbk: 16bit, 主要存放中文和亚洲字符. 兼容ascii</li><li>unicode: 16bit和32bit两个版本. 平时我们用的是16bit这个版本. 全世界所有国家的文字信息. 缺点: 浪费空间(传输和存储)</li><li>utf-8 : 可变长度unicode, 英文: 8bit, 欧洲文字: 16bit, 中文24bit. 一般数据传输和存储的时候使用.</li><li>以上所有编码必须兼容ascii .</li></ol><p>内存中使用的是unicode ，一个/x就是一个字节，一个汉字三个字节</p><p>gbk中，一个汉字两个字节</p><p><u>编码用encode()  解码用decode()</u></p><p>不同的编码之间是不能进行转换的，若想转换，可以先解码再编码</p><p>一个字节8个0和1</p><h2 id="基础数据类型bool"><a class="header-anchor" href="#基础数据类型bool">¶</a>基础数据类型bool</h2><p>所有表示空的东西都是False</p><p>基本数据类型之间的转化, 想变成谁, 就用谁把数据括起来</p><h2 id="基础数据类型str"><a class="header-anchor" href="#基础数据类型str">¶</a>基础数据类型str</h2><p>把字符连成串. 在python中用’, &quot;, ‘’', “”&quot;引起来的内容被称为字符串.</p><p>字符串: 把多个字符连成串</p><h4 id="字符串索引和切片"><a class="header-anchor" href="#字符串索引和切片">¶</a>字符串索引和切片</h4><p>索引从0开始</p><p>切片:</p><p>s[start: end: step]</p><p>start: 起始位置</p><p>end: 结束位置, 取不到</p><p>step: 步长（步长如果是负数，从右往左取数字）.</p><h4 id="常用API"><a class="header-anchor" href="#常用API">¶</a>常用API</h4><ol><li><p>upper(), 把字符串中所有的字母都变成大写. 主要使用在忽略大小写的时候用</p></li><li><p>strip(), 默认去掉左右两端的空白, 包括\n, \t, 空格.</p></li><li><p>replace(), 字符串替换</p></li><li><p>split(),  字符串切割. 得到字符串列表</p></li><li><p>join(),  把列表重新组合成字符串</p><pre><code class="language-python">lst = ['周杰伦', '王力宏', '麻花藤'] s = &quot;_&quot;.join(lst) print(s)  # 周杰伦_王力宏_麻花藤           </code></pre></li><li><p>startswith(),  判断是否以xxxx开头</p></li><li><p>endwith(),判断是否以xx结尾</p></li><li><p>find(), 查找xxxx</p></li><li><p>index()，求索引位置，如果找不到系统会报错</p></li><li><p>count(), 数数, 查看xxx出现的次数</p></li><li><p>isdigit(), 判断该字符串是否是由数字组成</p></li><li><p>len(), 字符串长度, 它是一个内置函数, 直接len(数据)即可</p></li><li><p>capitalize(),首字母变成大写</p></li><li><p>dir(),能查看这个数据类型能执行哪些操作</p></li></ol><pre><code class="language-python">for 变量 in 可迭代对象（不能放数字在这里）:循环体</code></pre><h4 id="关于in"><a class="header-anchor" href="#关于in">¶</a>关于in</h4><pre><code class="language-python"> '''   in有两种用法:     1. 在for中. 是把每一个元素获取到赋值给前面的变量.    2. 不在for中. 判断xxx是否出现在str中. ''' print('VUE' in s19)      </code></pre><h4 id="字符串的格式化输出"><a class="header-anchor" href="#字符串的格式化输出">¶</a>字符串的格式化输出</h4><pre><code class="language-python">name = 'Jay'age = 8s1 = &quot;我叫%s,我今年%d岁了&quot; % (name,age)print(s1)s2 = f&quot;我叫&#123;name&#125;,我今年&#123;age&#125;岁了&quot;print(s2)#按照位置格式化s3 = &quot;我叫&#123;&#125;,我今年&#123;&#125;岁了&quot;.format(name,age)print(s3)#按照函数中参数顺序分别填入对应相应的参数，从0开始，不得越界s4 = &quot;我叫&#123;1&#125;,我今年&#123;0&#125;岁了&quot; .format(name,age)print(s4)s5 = &quot;我叫&#123;aname&#125;,我今年&#123;aage&#125;岁了&quot; .format(aname=name,aage=age)print(s5)</code></pre><p><u>字符串是不可变的对象, 所以任何操作对原字符串是不会有任何影响的</u></p><h2 id="基础数据类型list"><a class="header-anchor" href="#基础数据类型list">¶</a>基础数据类型list</h2><p>列表是python的基础数据类型之一 ,其他编程语言也有类似的数据类型. 比如JS中的数组, java中的数组等等. 它是以[ ]括起来, 每个元素用’ , '隔开而且可以存放各种数据类型.</p><p>列表相比于字符串. 不仅可以存放不同的数据类型. 而且可以存放大量的数据. 32位python可以存放: 536870912个元素, 64位可以存放: 1152921504606846975个元素.而且列表是有序的(按照你保存的顺序),有索引, 可以切片方便取值.</p><h4 id="索引和切片"><a class="header-anchor" href="#索引和切片">¶</a>索引和切片</h4><p>和字符串中索引和切片操作基本相同，不同的是列表中的数据类型是list</p><p><u>列表是一个可变的数据类型</u></p><h4 id="列表查常用操作"><a class="header-anchor" href="#列表查常用操作">¶</a>列表查常用操作</h4><h5 id="增加"><a class="header-anchor" href="#增加">¶</a>增加</h5><p>注意, list和str是不一样的. list可以发生改变. 所以直接就在原来的对象上进行了操作</p><p>append的效率高于insert</p><pre><code class="language-python">lst = [&quot;麻花藤&quot;, &quot;林俊杰&quot;, &quot;周润发&quot;, &quot;周芷若&quot;] print(lst) lst.append(&quot;wusir&quot;) print(lst) lst = [] while True:       content = input(&quot;请输入你要录入的员工信息, 输入Q退出:&quot;)       if content.upper() == 'Q':             break       lst.append(content) print(lst) lst = [&quot;麻花藤&quot;, &quot;张德忠&quot;, &quot;孔德福&quot;] lst.insert(1, &quot;刘德华&quot;)  # 在1的位置插入刘德华. 原来的元素向后移动一位 print(lst) # 迭代添加 lst = [&quot;王志文&quot;, &quot;张一山&quot;, &quot;苦海无涯&quot;] lst.extend([&quot;麻花藤&quot;, &quot;麻花不疼&quot;]) print(lst)          </code></pre><h5 id="删除"><a class="header-anchor" href="#删除">¶</a>删除</h5><p>pop, remove, clear, del</p><pre><code class="language-python">lst = [&quot;麻花藤&quot;, &quot;王剑林&quot;, &quot;李嘉诚&quot;, &quot;王富贵&quot;] print(lst) deleted = lst.pop()     # 默认删除最后一个 print(&quot;被删除的&quot;, deleted) print(lst) el = lst.pop(2)   # 删除2号元素 print(el) print(lst) lst.remove(&quot;麻花藤&quot;)  # 删除指定元素 print(lst) # lst.remove(&quot;哈哈&quot;)  # 删除不存在的元素会报错 # print(lst) lst.clear()   # 清空list print(lst) # 切片删除 del lst[1:3] print(lst)   </code></pre><h5 id="修改"><a class="header-anchor" href="#修改">¶</a>修改</h5><p>索引切片修改</p><pre><code class="language-python"># 修改lst = [&quot;得儿得儿&quot;, &quot;太牛&quot;, &quot;胡辣汤&quot;, &quot;王者荣耀&quot;, &quot;科科&quot;] lst[1] = &quot;太污&quot;  # 把1号元素修改成太污 print(lst) lst[1:4:3] = [&quot;麻花藤&quot;, &quot;哇靠&quot;]   # 切片修改也OK. 如果步长不是1, 要注意. 元素的个数 print(lst) lst[1:4] = [&quot;压了个嘿嘿&quot;] # 如果切片没有步长或者步长是1. 则不用关心个数 print(lst)    </code></pre><h5 id="查询"><a class="header-anchor" href="#查询">¶</a>查询</h5><p>列表是一个可迭代对象, 所以可以进行for循环</p><pre><code class="language-python">for el in lst:       print(el)     </code></pre><h5 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h5><pre><code class="language-python">lst = [&quot;小白&quot;, &quot;小黑&quot;, &quot;腾哥&quot;, &quot;马总&quot;, &quot;日天&quot;, &quot;小白&quot;] c = lst.count(&quot;小白&quot;)   # 查询太白出现的次数 print(c) lst = [1, 11, 22, 2] lst.sort()     # 排序. 默认升序 print(lst) lst.sort(reverse=True) # 降序 print(lst) lst = [&quot;小白&quot;, &quot;小黑&quot;, &quot;腾哥&quot;, &quot;马总&quot;, &quot;日天&quot;, &quot;白天&quot;] print(lst) lst.reverse() #翻转print(lst) l = len(lst)  # 列表的长度 print(l) #rang（让for循环去数数,顾头不顾尾）for num in range(10):    print(num)#输出0,1,...10for num in range(10, 1, -2):    # 反着来, 和切片一样    print(num)    #range最大的作用是可以循环出列表中每一个元素的索引lst = [&quot;周杰伦&quot;, &quot;马虎疼&quot;, &quot;疼不疼&quot;]for i in range(len(lst)):    print(i, lst[i])</code></pre><h4 id="列表的嵌套"><a class="header-anchor" href="#列表的嵌套">¶</a>列表的嵌套</h4><pre><code class="language-python">lst = [1, &quot;小白&quot;, &quot;小黑黑&quot;, [&quot;马虎疼&quot;, [&quot;可口可乐&quot;], &quot;王剑林&quot;], 'kounijiwa'] # 找到小白和小黑黑 print(lst[1:3]) # 找到小白的白字 print(lst[1][1]) # 将kounijiwa拿到. 然后首字母大写. 再扔回去 s = lst[4] s = s.capitalize() lst[4] = s print(lst) # 简写 lst[4] = lst[4].capitalize() print(lst) # 把马虎疼换成马化疼 lst[3][0] = lst[3][0].replace(&quot;虎&quot;, &quot;化&quot;) #lst[3][0].replace(&quot;虎&quot;, &quot;化&quot;) 产生一个新的字符串，要将字符串替换到原来的位置print(lst[3][0]) lst[3][1].append(&quot;雪碧&quot;) print(lst)     </code></pre><h4 id=""><a class="header-anchor" href="#">¶</a></h4><h2 id="基础数据类型tuple"><a class="header-anchor" href="#基础数据类型tuple">¶</a>基础数据类型tuple</h2><p>只读列表，元组也是python的基本数据类型之一, 用小括号括起来, 里面可以放任何数据类型的数据,  查询可以. 循环也可以. 切片也可以. 但就是不能改.</p><pre><code class="language-python">tu = (1, &quot;太白&quot;, &quot;李白&quot;, &quot;太黑&quot;, &quot;怎么黑&quot;) print(tu)print(tu[2:5]) # 切片之后还是元组 # for循环遍历元组 for el in tu:   print(el) # 尝试修改元组 # tu[1] = &quot;马虎疼&quot;  # 报错 'tuple' object does not support item assignment tu = (1, &quot;哈哈&quot;, [], &quot;呵呵&quot;) # tu[2] = [&quot;fdsaf&quot;]   这么改不行 tu[2].append(&quot;麻花藤&quot;)   # 可以改了. 没报错 print(tu)     </code></pre><p><strong><u>这里元组的不可变的意思是子元素不可变，元组内存的指向不可变. 而子元素内部的子元素是可以变, 这取决于子元素是否是可变对象.</u></strong></p><p><u>元组中如果只有一个元素. 一定要添加一个逗号, 否则就不是元组</u></p><pre><code class="language-python">tu = (1,) print(type(tu))     </code></pre><p>​</p><h2 id="基础数据类型dict"><a class="header-anchor" href="#基础数据类型dict">¶</a>基础数据类型dict</h2><p>字典(<code>dict</code>)是python中唯一的一个映射类型.他是以{ }括起来的键值对组成. 在<code>dict</code>中key是唯一的. 在保存的时候, 根据key来计算出一个内存地址. 然后将<code>key:value</code>保存在这个地址中. 这种算法被称为hash算法, 所以, 切记, 在<code>dict</code>中存储的<code>key:value</code>中的key’必须是可hash的, 如果你搞不懂什么是可哈希, 暂时可以这样记, 可以改变的都是不可哈希的, 那么可哈希就意味着不可变. 这个是为了能准确的计算内存地址而规定的.</p><p>已知的可哈希(不可变)的数据类型: int, str, tuple, bool</p><p>不可哈希(可变)的数据类型: list, dict, set</p><p>语法 :</p><p>{key1: value1, key2: value2…}</p><blockquote><p>注意:</p><p>key必须是不可变(可哈希)的. value没有要求.可以保存任意类型的数据</p><p>dict保存的数据不是按照我们添加进去的顺序保存的. 是按照hash表的顺序保存的. 而hash表不是连续的. 所以不能进行切片工作. 它只能通过key来获取dict中的数据</p></blockquote><h4 id="字典增删改查和其他操作"><a class="header-anchor" href="#字典增删改查和其他操作">¶</a>字典增删改查和其他操作</h4><p>增加</p><pre><code class="language-python">dic = &#123;&#125;dic['name'] = '周润发'     # 如果dict中没有出现这个key, 就会新增一个key-value的组合进dictprint(dic)# 如果dict中没有出现过这个key-value,key必须是不存在的. 可以通过setdefault设置默认值dic.setdefault('李嘉诚')   # 也可以往里面设置值.dic.setdefault(&quot;李嘉诚&quot;, &quot;房地产&quot;)    # 如果dict中已经存在了. 那么setdefault将不会起作用print(dic)</code></pre><p>删除(参考列表，没有remove)</p><pre><code class="language-python">ret = dic.pop(&quot;jay&quot;)#pop中加上keyprint(ret)del dic[&quot;jay&quot;]print(dic)# 清空字典中的所有内容dic.clear()</code></pre><p>修改</p><pre><code class="language-python">dic = &#123;&quot;id&quot;: 123, &quot;name&quot;: 'sylar', &quot;age&quot;: 18&#125;dic1 = &#123;&quot;id&quot;: 456, &quot;name&quot;: &quot;麻花藤&quot;, &quot;ok&quot;: &quot;wtf&quot;&#125;dic.update(dic1)    # 把dic1中的内容更新到dic中. 如果key重名. 则修改替换. 如果不存在key, 则新增.print(dic)</code></pre><p>查询（根据是否确定该key存在选择使用）</p><pre><code class="language-python">print(dic['name']) # 不存在 报错print(dic.get(&quot;sylar&quot;))      # 不存在 返回Noneprint(dic.get(&quot;sylar&quot;, &quot;牛B&quot;))   # 牛B#setdefault 在执行完新增流程后，会根据key查询valueprint(dic.setdefault(&quot;sylar&quot;))   </code></pre><p>循环</p><pre><code class="language-python">dic = &#123;&quot;id&quot;: 123, &quot;name&quot;: 'sylar', &quot;age&quot;: 18, &quot;ok&quot;: &quot;科比&quot;&#125;#第一种for k in dic:    print(k)    # dict.keys(['id', 'name', 'age', 'ok']) 不用管它是什么.当成list来用就行for key in dic.keys():    print(key)# dict.values([123, 'sylar', 18, '科比']) 当list来用for value in dic.values():    print(value)# dict_items([('id', 123), ('name', 'sylar'), ('age', 18), ('ok', '科比')]) 这个东西也是list. 只不过list中装的是tuplefor key, value in dic.items(): #解构    print(key, value)# 解构a = 1, 2print(a) #类型是元组（1,2）(c, d) = 3, 4print(c, d)#分别输出3,4 类型都是int# 解构的时候注意数量必须匹配 错误写法 最多两个元素e, f = [1, 2, 3]    print(e, f)</code></pre><h4 id="字典的嵌套"><a class="header-anchor" href="#字典的嵌套">¶</a>字典的嵌套</h4><pre><code class="language-python">dic1 = &#123;    &quot;name&quot;: &quot;汪峰&quot;,    &quot;age&quot;: 18,    &quot;wife&quot;: &#123;        &quot;name&quot;: '章子怡',        &quot;age&quot;: 28    &#125;,    &quot;children&quot;: ['第一个毛孩子', '第二个毛孩子'],    &quot;desc&quot;: '峰哥不会告我吧. 没关系. 我想上头条的'&#125;print(dic1.get(&quot;wife&quot;).get(&quot;name&quot;))print(dic1.get(&quot;children&quot;)[1])</code></pre><h2 id="基本数据类型Set"><a class="header-anchor" href="#基本数据类型Set">¶</a>基本数据类型Set</h2><p>set集合是python的一个基本数据类型. 一般不是很常用. set中的元素是不重复的.无序的.里面的元素必须是可hash的(int, str, tuple,bool), 我们可以这样来记. set就是<code>dict</code>类型的数据但是不保存value, 只保存key. set也用{}表示</p><p><code>add</code> 增加</p><p><code>remove</code>修改 先把要修改的内容删除，然后新增一个新的</p><p>最主要的操作: 去重复, 交,并,差</p><pre><code class="language-python">s1 = &#123;&quot;刘能&quot;, &quot;赵四&quot;, &quot;皮长山&quot;&#125;s2 = &#123;&quot;刘科长&quot;, &quot;冯乡长&quot;, &quot;皮长山&quot;&#125;# 交集# 两个集合中的共有元素print(s1 &amp; s2)  # &#123;'皮长山'&#125;print(s1.intersection(s2))  # &#123;'皮长山'&#125;# 并集print(s1 | s2)  # &#123;'刘科长', '冯乡长', '赵四', '皮长山', '刘能'&#125;print(s1.union(s2))     # &#123;'刘科长', '冯乡长', '赵四', '皮长山', '刘能'&#125;# 差集print(s1 - s2)  # &#123;'赵四', '刘能'&#125; 得到第一个中单独存在的print(s1.difference(s2))     # &#123;'赵四', '刘能'&#125;</code></pre><h2 id="深浅copy"><a class="header-anchor" href="#深浅copy">¶</a>深浅copy</h2><pre><code class="language-python">lst1 = [&quot;金毛狮王&quot;, &quot;紫衫龙王&quot;, &quot;白眉鹰王&quot;, &quot;青翼蝠王&quot;]#并没有产生新的对象 而是把原来的内存地址 赋给list2lst2 = lst1print(lst1)print(lst2)lst1.append(&quot;杨逍&quot;)print(lst1)print(lst2)结果:['金毛狮王', '紫衫龙王', '白眉鹰王', '青翼蝠王', '杨逍']['金毛狮王', '紫衫龙王', '白眉鹰王', '青翼蝠王', '杨逍']#可以通过 id(list1) 来查看list1的地址dic1 = &#123;&quot;id&quot;: 123, &quot;name&quot;: &quot;谢逊&quot;&#125;dic2 = dic1print(dic1)  # &#123;'id': 123, 'name': '谢逊'&#125;print(dic2)  # &#123;'id': 123, 'name': '谢逊'&#125;dic1['name'] = &quot;范瑶&quot;print(dic1)  # &#123;'id': 123, 'name': '范瑶'&#125;print(dic2)  # &#123;'id': 123, 'name': '范瑶'&#125;</code></pre><h4 id="浅拷贝"><a class="header-anchor" href="#浅拷贝">¶</a>浅拷贝</h4><pre><code class="language-python">lst1 = [&quot;何炅&quot;, &quot;杜海涛&quot;,&quot;周渝民&quot;]lst2 = lst1.copy()lst1.append(&quot;李嘉诚&quot;)print(lst1)print(lst2)print(id(lst1), id(lst2))结果: 两个lst完全不一样. 内存地址和内容也不一样. 发现实现了内存的拷贝lst1 = [&quot;何炅&quot;, &quot;杜海涛&quot;,&quot;周渝民&quot;, [&quot;麻花藤&quot;, &quot;马芸&quot;, &quot;周笔畅&quot;]]lst2 = lst1.copy()lst1[3].append(&quot;无敌是多磨寂寞&quot;)print(lst1)print(lst2)print(id(lst1[3]), id(lst2[3]))结果: ['何炅', '杜海涛', '周渝民', ['麻花藤', '马芸', '周笔畅', '无敌是多磨寂寞']]['何炅', '杜海涛', '周渝民', ['麻花藤', '马芸', '周笔畅', '无敌是多磨寂寞']]4417248328 4417248328</code></pre><p>只会拷贝第一层. 第二层的内容不会拷贝，还是指向原地址. 所以被称为浅拷贝</p><h4 id="深拷贝"><a class="header-anchor" href="#深拷贝">¶</a>深拷贝</h4><p>必须使用copy模块</p><pre><code class="language-python">import copylst1 = [&quot;何炅&quot;, &quot;杜海涛&quot;,&quot;周渝民&quot;, [&quot;麻花藤&quot;, &quot;马芸&quot;, &quot;周笔畅&quot;]]lst2 = copy.deepcopy(lst1)lst1[3].append(&quot;无敌是多磨寂寞&quot;)print(lst1)print(lst2)print(id(lst1[3]), id(lst2[3]))结果:['何炅', '杜海涛', '周渝民', ['麻花藤', '马芸', '周笔畅', '无敌是多磨寂寞']]['何炅', '杜海涛', '周渝民', ['麻花藤', '马芸', '周笔畅']]4447221448 4447233800</code></pre><p>深度拷贝. 把元素内部的元素完全进行拷贝复制. 不会产生一个改变另一个跟着改变的问题</p><h2 id="知识点补充"><a class="header-anchor" href="#知识点补充">¶</a>知识点补充</h2><h4 id="列表和字典循环的时候不能删除"><a class="header-anchor" href="#列表和字典循环的时候不能删除">¶</a>列表和字典循环的时候不能删除</h4><p>python中的列表和字典在循环的时候. 不能删除自身中的元素. 列表虽然不报错，但是删不干净.  对于字典, 直接报错. 不让删. 解决方案都一样, 把要删除的内容保存在一个新列表中, 循环新列表, 删除老列表.</p><p>每次remove后，后面的元素都会向前挪，但是指针位置还是不变的，导致前挪动的元素，如果符合条件，就不会被删除</p><pre><code class="language-python">lst = [&quot;张无忌&quot;, &quot;张翠山&quot;, &quot;灭绝师太&quot;, &quot;胡辣汤&quot;]new_lst = []for name in lst:    if name.startswith(&quot;张&quot;):        new_lst.append(name)#法一        for name in new_lst:    lst.remove(name)#法二 新产生的字符串与原字符串指向同一地址for name in lst[:]:    if name.startswith('张'):        lst.remove(name)        print(lst) # [&quot;灭绝师太&quot;, &quot;胡辣汤&quot;] </code></pre><p>字典操作与列表类似，可以选择存储keys</p><h4 id="is和-的区别"><a class="header-anchor" href="#is和-的区别">¶</a>is和==的区别</h4><p>== 判断的是内容. ==&gt;  两个人长的是不是一样?</p><p>is   判断的是内存地址.  ==&gt;  两个人是不是同一个人</p><p><u>此结论不适合字符串.</u></p><h4 id="while…else"><a class="header-anchor" href="#while…else">¶</a>while…else</h4><pre><code class="language-python">while 条件:    循环体else: 循环在正常情况跳出之后会执行这里</code></pre><p>如果循环是通过break退出的. 那么while后面的else将不会被执行, 只有在while条件判断是假的时候才会执行这个else</p><p><code>pass</code>: <u>不表示任何内容. 为了代码的完整性.  占位而已</u></p><h2 id="文件操作"><a class="header-anchor" href="#文件操作">¶</a>文件操作</h2><p><code>               f = open(文件, mode=&quot;模式&quot; encoding=&quot;编码&quot;)             </code></p><p>f被称为文件句柄，负责操纵你打开的这个文件</p><h4 id="模式"><a class="header-anchor" href="#模式">¶</a>模式:</h4><p>r: 只读</p><p>w: 只写  如果没有文件. 则会创建文件, 如果文件存在. 则将原件中原来的内容删除, 再写入新内容</p><pre><code class="language-python">f.write(&quot;\n&quot;) 换行</code></pre><p>a: 追加写    追加写，不会重新创建文件，但是如果文件不存在，可以创建文件</p><p>+: 扩展      不是很好用</p><p>b: 字节(非文本文件，可理解为二进制文件，不能指定encoding)</p><pre><code class="language-python">#s实现文件复制f1=open(&quot;a/tu.jpg&quot;,mode=&quot;rb&quot;)f2=open(&quot;c/yu.jpg&quot;,mode=&quot;wb&quot;)for line in f1:f2.write(line)</code></pre><h4 id="读取文件的方法"><a class="header-anchor" href="#读取文件的方法">¶</a>读取文件的方法</h4><ol><li>read()  将文件中的内容全部读取出来. 弊端: 占内存. 如果文件过大.容易导致内存崩溃</li><li>read(n) 读取n个字符. 需要注意的是. 如果再次读取. 那么会在当前位置继续去读而不是从头读, 如果使用的是rb模式. 则读取出来的是n个字节</li><li>readline() 一次读取一行数据, 注意: readline()结尾, 注意每次读取出来的数据都会有一个\n 所以呢. 需要我们使用strip()方法来去掉\n或者空格</li><li>readlines()将每一行形成一个元素, 放到一个列表中. 将所有的内容都读取出来. 所以也是. 容易出现内存崩溃的问题.不推荐使用</li><li>循环读取 读取文件最好的方案</li></ol><pre><code class="language-python">#另一种写法，可以不用`close` 使用with()自动加入 '\'可以用来表示一行的连接    with open() as f1,\     open() as f2:        for line in f1:            f2.write(line)            print(line.strip())#去掉换行xxxxx</code></pre><p><strong>读取完的文件句柄一定要关闭 <code> f.close()</code>，</strong></p><p>​</p><h4 id="修改文件"><a class="header-anchor" href="#修改文件">¶</a>修改文件:</h4><ol><li>创建一个文件副本.</li><li>把源文件中的内容读取到内存.</li><li>然后在内存中进行修改.</li><li>修改之后保存在文件副本中.</li><li>把源文件删除</li><li>把文件副本更改名称为源文件的名称</li></ol><pre><code class="language-python"># 文件修改import oswith open(&quot;小娃娃&quot;, mode=&quot;r&quot;, encoding=&quot;utf-8&quot;) as f1,\     open(&quot;小娃娃_new&quot;, mode=&quot;w&quot;, encoding=&quot;UTF-8&quot;) as f2:    content = f1.read()    new_content = content.replace(&quot;冰糖葫芦&quot;, &quot;大白梨&quot;)    f2.write(new_content)os.remove(&quot;小娃娃&quot;)    # 删除源文件os.rename(&quot;小娃娃_new&quot;, &quot;小娃娃&quot;)     # 重命名新文件</code></pre><p>弊端: 一次将所有内容进行读取. 内存溢出. 解决方案: 一行一行的读取和操作</p><pre><code class="language-python">import oswith open(&quot;小娃娃&quot;, mode=&quot;r&quot;, encoding=&quot;utf-8&quot;) as f1,\     open(&quot;小娃娃_new&quot;, mode=&quot;w&quot;, encoding=&quot;UTF-8&quot;) as f2:    for line in f1:        new_line = line.replace(&quot;大白梨&quot;, &quot;冰糖葫芦&quot;)        f2.write(new_line)os.remove(&quot;小娃娃&quot;)    # 删除源文件os.rename(&quot;小娃娃_new&quot;, &quot;小娃娃&quot;)     # 重命名新文件</code></pre><p>​</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在学py，简单记录一下笔记&lt;/p&gt;</summary>
    
    
    
    <category term="语言学习" scheme="http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="PYTHON" scheme="http://example.com/tags/PYTHON/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记（1）入门</title>
    <link href="http://example.com/2022/09/15/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
    <id>http://example.com/2022/09/15/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</id>
    <published>2022-09-15T01:50:59.963Z</published>
    <updated>2022-09-15T08:54:21.123Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学py，简单记录一下笔记</p><span id="more"></span><p>IDLE 常用的快捷键</p><table><thead><tr><th>含义</th><th>快捷键</th></tr></thead><tbody><tr><td>增加代码块缩进</td><td>Ctrl+]</td></tr><tr><td>减少代码块缩进</td><td>Ctrl+[</td></tr><tr><td>注释代码块</td><td>Alt+3</td></tr><tr><td>取消代码块注释</td><td>Alt+4</td></tr><tr><td>浏览上一条输入的命令</td><td>Alt+p</td></tr><tr><td>浏览下一条输入的命令</td><td>Alt+n</td></tr><tr><td>补全单词，列出全部可选单词供选择</td><td>Tab</td></tr></tbody></table><ul><li>Python中对空格的应用很严格 运算时 运算符要与其他数据加上空格隔开</li></ul><h3 id="注释"><a class="header-anchor" href="#注释">¶</a>注释</h3><p>单行注释<code>#</code></p><p>多行注释<code>'''</code>3 个单引号<code>&quot;&quot;&quot;</code>3 个双引号</p><h3 id="变量以及变量命名规范"><a class="header-anchor" href="#变量以及变量命名规范">¶</a>变量以及变量命名规范</h3><p>标识符是在程序中用来标识诸如变量、函数、类、对象等名字的符号。在 Python 中，<br>用标识符来标识变量，变量在使用前都必须被赋值，变量被赋值后变量才会被创建。在 Python<br>中，变量是用一个变量名表示，也就是一个标识符来表示，变量名的命名规则：</p><p>（1）变量名只能是字母、数字或下划线的任意组合。<br>（2）变量名的第一个字符不能是数字。<br>（3） Python 关键字不能声明为变量名：</p><p>推荐使用驼峰体或者下划线命名</p><blockquote><p>驼峰体: 除首字母外的其他每个单词首字母大写</p><p>下划线: 每个单词之间用下划线分开</p></blockquote><p><strong>类型属于对象，变量是没有类型的，变量只是对象的引用，所谓变量的类型指的是变量所引用的对象的类型。变量的类型随着所赋值的类型的变化而改变。</strong></p><p>变量的数据类型:</p><p>int, 整数, 加减乘除, 余数, 整除</p><p>str, 字符串, ‘, &quot;, ‘’’, “”&quot;都是字符串, 操作: +, *</p><p>bool，布尔值. True, False</p><p>​</p><h3 id="常量"><a class="header-anchor" href="#常量">¶</a>常量</h3><p>Python中不存在绝对的常量，只要字母大写就是常量</p><h3 id="用户交互"><a class="header-anchor" href="#用户交互">¶</a>用户交互</h3><p><code>input()</code></p><p><strong>input获取到数据都是字符串类型, 如果想要进行数学运算或者比较. 必须转化成int()</strong></p><h3 id="条件分支"><a class="header-anchor" href="#条件分支">¶</a>条件分支</h3><pre><code class="language-python">if 条件:    # 引号是将条件与结果分开。结果   # 四个空格，或者一个tab键，这个是告诉程序满足这个条件的   elif 条件2:   结果2... else:   结果n </code></pre><p>当条件成立. 执行相应的结果.</p><p>​</p><h3 id="循环分支"><a class="header-anchor" href="#循环分支">¶</a>循环分支</h3><pre><code class="language-python">while 条件:   循环体 </code></pre><p>只要条件成立. 就一直执行循环体. 每次执行完循环体. 重新判断条件</p><h3 id="流程控制-break和continue"><a class="header-anchor" href="#流程控制-break和continue">¶</a>流程控制-break和continue</h3><p><code>break</code>: 立刻跳出循环. 打断的意思.</p><p><code>continue</code>: 结束当前这一次循环，跳过后面可能存在的信息，即继续执行下一次循环</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在学py，简单记录一下笔记&lt;/p&gt;</summary>
    
    
    
    <category term="语言学习" scheme="http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="PYTHON" scheme="http://example.com/tags/PYTHON/"/>
    
  </entry>
  
  <entry>
    <title>C++ STL简介</title>
    <link href="http://example.com/2022/09/05/C++%20STL%E7%AE%80%E4%BB%8B/"/>
    <id>http://example.com/2022/09/05/C++%20STL%E7%AE%80%E4%BB%8B/</id>
    <published>2022-09-05T13:33:15.027Z</published>
    <updated>2022-09-15T01:59:48.363Z</updated>
    
    <content type="html"><![CDATA[<p>C/C++常用stl及api用法</p><span id="more"></span><p>每个容器都有的api</p><p><code>size() </code> 返回元素个数 O(1)</p><p><code> empty()</code>  返回是否为空O(1)</p><p><code>clear()</code> 清空队列无O(n)</p><h3 id="vector"><a class="header-anchor" href="#vector">¶</a>vector</h3><p>vector, 变长数组，倍增的思想<br><code>clear()</code>  清空<br><code>front()/back()</code>取队头或者对位<br><code>push_back()/pop_back()</code>  插入最后一个数\删除最后一个数<br>``begin()/end()`  迭代器</p><p>​    支持比较运算，按字典序</p><blockquote><p>定义一个长度为n,ing且里面的每一个数字都初始化为m的vector数组</p><p><code>vector&lt;int&gt; a(n,m)</code></p><p>系统为某一程序分配空间时所需时间，与空间大小无关，与申请所需要的次数有关</p><p>vector具有空间不足，自动扩容（倍增）的机制，并且完成自我复制</p></blockquote><h3 id="pair-int-int"><a class="header-anchor" href="#pair-int-int">¶</a>pair&lt;int, int&gt;</h3><p>相当于二元结构体，并内置比较函数</p><p>​    <code>first</code>, 第一个元素<br>​    <code>second</code>, 第二个元素<br>​    支持比较运算，以<code>first</code>为第一关键字，以<code>second</code>为第二关键字（字典序）</p><h3 id="string，字符串"><a class="header-anchor" href="#string，字符串">¶</a>string，字符串</h3><p>​    <code>length()</code>  返回字符串长度<br>​    <code>substr(起始下标，(子串长度))</code>  返回子串<br><code>c_str()</code> 返回字符串所在字符数组的起始地址</p><h3 id="queue-队列"><a class="header-anchor" href="#queue-队列">¶</a>queue, 队列</h3><p><code>push()</code>  向队尾插入一个元素<br><code>front()</code>  返回队头元素<br><code>back()</code>  返回队尾元素<br><code>pop()</code>  弹出队头元素</p><h3 id="priority-queue"><a class="header-anchor" href="#priority-queue">¶</a>priority_queue</h3><p>priority_queue, 优先队列，默认是大根堆</p><p>​    <code>push()</code>  插入一个元素<br><code>top()</code>  返回堆顶元素<br>​    <code>pop()</code>  弹出堆顶元素<br>​    定义成小根堆的方式：<code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q</code>;</p><blockquote><p>greater表示内置类型从大到小排序，less表示内置类型从小到大排序。</p></blockquote><h3 id="stack-栈"><a class="header-anchor" href="#stack-栈">¶</a>stack, 栈</h3><p><code>push()</code>  向栈顶插入一个元素</p><p><code> top()</code>  返回栈顶元素</p><p><code> pop()</code>  弹出栈顶元素</p><h3 id="deque-双端队列"><a class="header-anchor" href="#deque-双端队列">¶</a>deque, 双端队列</h3><p>效率很低撒~</p><p>​    <code>front()/back()</code><br>​    <code>push_back()/pop_back()</code><br>​    <code>push_front()/pop_front()</code><br>​    <code>begin()/end()</code><br>​</p><h3 id="set-map-multiset-multimap"><a class="header-anchor" href="#set-map-multiset-multimap">¶</a>set, map, multiset, multimap</h3><p>基于平衡二叉树（红黑树），动态维护有序序列</p><p>​    <code>size()</code><br>​    <code>empty()</code><br>​    <code>clear()</code><br>​    <code>begin()/end()</code><br>​    <code>++, --</code> 返回前驱和后继，时间复杂度 O(logn)</p><h4 id="set-multiset"><a class="header-anchor" href="#set-multiset">¶</a>set/multiset</h4><p><code>insert()</code>  插入一个数</p><p><code>find()</code>  查找一个数</p><p><code>count()</code>  返回某一个数的个数</p><p><code> erase()</code></p><ol><li><p>输入一个数x，删除所有xO(k+logn) k是个数</p></li><li><p>输入一个迭代器，删除这个迭代器</p></li><li><p>​        输入是一个数x，删除所有x   O(k + logn)</p></li><li><p>​        输入一个迭代器，删除这个迭代器</p></li></ol><p><code> lower_bound()/upper_bound()</code><br><code>lower_bound(x)</code>  返回大于等于x的最小的数的迭代器<br><code> upper_bound(x)</code>  返回大于x的最小的数的迭代器</p><h4 id="map-multimap"><a class="header-anchor" href="#map-multimap">¶</a>map/multimap</h4><p>​    <code>insert()</code>  插入的数是一个pair（表现为映射）<br><code> erase()</code>  输入的参数是pair或者迭代器<br>​    <code>find()</code><br>​     注意multimap不支持此操作。 时间复杂度是 O(logn)<br>​    <code>lower_bound()/upper_bound()</code></p><h4 id="unordered-set-unordered-map-unordered-multiset-unordered-multimap-哈希表"><a class="header-anchor" href="#unordered-set-unordered-map-unordered-multiset-unordered-multimap-哈希表">¶</a>unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</h4><p>​内部无序</p><p>​    和上面类似，增删改查的时间复杂度是 O(1)<br>​    不支持 <code>lower_bound()/upper_bound()</code>， 迭代器的++，–</p><h3 id="bitset-圧位"><a class="header-anchor" href="#bitset-圧位">¶</a>bitset, 圧位</h3><p>省八位空间</p><blockquote><p>bitset是一个多位二进制数，每八位占用一个字节，因为支持基本的位运算，所以可用于状态压缩，n位bitset执行一次位运算的时间复杂度可视为n/32.</p><p><code>bitset&lt;10000&gt; s;</code></p></blockquote><p>支持的符号操作</p><p><code> ~, &amp;, |, ^</code><br><code> &gt;&gt;, &lt;&lt;</code><br><code>==, !=</code></p><p><code>count()</code>  返回有多少个1</p><p><code>any()</code>  判断是否至少有一个1<br><code>none()</code>  判断是否全为0</p><p><code>set() </code> 把所有位置成1<br><code>set(k, v)</code>  将第k位变成v<br><code>reset()</code>  把所有位变成0<br><code>flip()</code>  等价于~<br><code>flip(k)</code> 把第k位取反</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;C/C++常用stl及api用法&lt;/p&gt;</summary>
    
    
    
    <category term="语言学习" scheme="http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C/C++" scheme="http://example.com/tags/C-C/"/>
    
    <category term="others" scheme="http://example.com/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>堆排序（数组模拟）</title>
    <link href="http://example.com/2022/09/04/%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%EF%BC%89/"/>
    <id>http://example.com/2022/09/04/%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%EF%BC%89/</id>
    <published>2022-09-04T07:07:17.328Z</published>
    <updated>2022-09-15T02:06:56.514Z</updated>
    
    <content type="html"><![CDATA[<p>堆是特殊的队列，特殊的点就在于它可以依照元素的优先级取出，而不是元素入队的先后顺序。</p><span id="more"></span><p>堆常表现为完全二叉树的形式，因为高度为h的完全二叉树有结点 2<sup>(k-1)到2</sup>k-1个，且结点排布极共规律，因此，通常不必用指针，而是用数组来实现堆的存储。</p><p><img src="/images/%E5%A0%86%E6%8E%92%E5%BA%8F.png" alt="image-20220904145447744"></p><p>堆排序核心操作，建堆</p><pre><code class="language-c++">void down(int u)&#123;int t=u;//构建平衡二叉搜索树if( 2*u&lt;=cnt &amp;&amp; h[2*u]&lt;h[t] ) t=2*u;if( 2*u+1 &lt;= cnt &amp;&amp; h[2*u+1]&lt;h[t]) t=2*u+1;//代表树的位置已经发生变化,递归直到u==t时结束if(u!=t)&#123;    swap(h[u],h[t]);    down(t);&#125;&#125;</code></pre><p>只要理解平衡二叉树的原理就好</p><p>完整代码</p><pre><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e5+10;int n,m;//cnt记录结点数，h数组模拟树int cnt,h[N];void down(int u)&#123;int t=u;if( 2*u&lt;=cnt &amp;&amp; h[2*u]&lt;h[t] ) t=2*u;if( 2*u+1 &lt;= cnt &amp;&amp; h[2*u+1]&lt;h[t]) t=2*u+1;if(u!=t)&#123;    swap(h[u],h[t]);    down(t);&#125;&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n ,&amp;m );    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;h[i]);//更新cntcnt=n;//从树顶开始向下递归for (int i = n/2; i ; i -- )down(i);while (m -- )&#123;    printf(&quot;%d &quot;,h[1]);    //保证每次输出的顶都是最小的    h[1]=h[cnt--];    down(1);&#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;堆是特殊的队列，特殊的点就在于它可以依照元素的优先级取出，而不是元素入队的先后顺序。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="ALGO" scheme="http://example.com/tags/ALGO/"/>
    
    <category term="C/C++" scheme="http://example.com/tags/C-C/"/>
    
    <category term="others" scheme="http://example.com/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>算法学习的一些零碎知识点</title>
    <link href="http://example.com/2022/08/28/%E9%9B%B6%E9%9B%B6%E7%A2%8E%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://example.com/2022/08/28/%E9%9B%B6%E9%9B%B6%E7%A2%8E%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2022-08-28T10:00:20.602Z</published>
    <updated>2022-09-05T09:48:10.473Z</updated>
    
    <content type="html"><![CDATA[<p>随笔记录一下日常学习遇到的points</p><span id="more"></span><h3 id="无穷大"><a class="header-anchor" href="#无穷大">¶</a>无穷大</h3><p>在算法竞赛中，我们常常需要用到设置一个常量用来代表“无穷大”。</p><p>比如对于int类型的数，有的人会采用INT_MAX，即0x7fffffff作为无穷大。但是以INT_MAX为无穷大常常面临一个问题，即加一个其他的数会溢出。</p><p>而这种情况在动态规划，或者其他一些递推的算法中常常出现，很有可能导致算法出问题。</p><p>所以在算法竞赛中，我们常采用0x3f3f3f3f来作为无穷大。0x3f3f3f3f主要有如下好处：</p><p>0x3f3f3f3f的十进制为1061109567，和INT_MAX一个数量级，即10<sup>9数量级，而一般场合下的数据都是小于10</sup>9的。<br>0x3f3f3f3f * 2 = 2122219134，无穷大相加依然不会溢出。<br>可以使用memset(array, 0x3f, sizeof(array))来为数组设初值为0x3f3f3f3f，因为这个数的每个字节都是0x3f。</p><h3 id="memset"><a class="header-anchor" href="#memset">¶</a>memset</h3><p>memset函数是按照字节直接来对数组进行赋值，比如h为一个int类型数组，有四个字节<br><code>memset( h , 0x3f ,sizeof h )</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随笔记录一下日常学习遇到的points&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="ALGO" scheme="http://example.com/tags/ALGO/"/>
    
    <category term="others" scheme="http://example.com/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>c语言中的&amp;的用法</title>
    <link href="http://example.com/2022/08/28/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84&amp;%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://example.com/2022/08/28/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84&amp;%E7%9A%84%E7%94%A8%E6%B3%95/</id>
    <published>2022-08-28T08:36:26.279Z</published>
    <updated>2022-08-28T11:59:38.329Z</updated>
    
    <content type="html"><![CDATA[<p>在做题时，经常会看到在数字或者字符串前面加上&amp;，之前一直没太注意这个单目&amp;，下面总结一下&amp;的用法。😗</p><span id="more"></span><h3 id="取地址（指针赋值）"><a class="header-anchor" href="#取地址（指针赋值）">¶</a>取地址（指针赋值）</h3><p>个人认为c语言中，比较不容易理解的就是指针了。</p><p>举一个该情况下使用&amp;的例子</p><pre><code class="language-c">#include&lt;stdio.h&gt;int main()&#123;    int a = 2;        int*b;//定义一个整形指针        b = &amp;a;//给指针赋值，使指针指向a的地址        printf(&quot;%d&quot;, b);//输出的是a的地址    printf(&quot;%d&quot;, *b);//*的作用是解引用，取出指针指向地址的内容,本例里输出的是2    return 0;&#125;</code></pre><p>由于使用&amp;（引用）的时候，跟原数指向的是一个地址，故也不会造成每次使用都新开辟一个内存，相当于JAVA中的静态变量</p><p>比如接下来在Tire中的一个<code>insert</code>操作（将相应的数字存储在Tire上，以便于接下来的操作）</p><pre><code class="language-c">void insert(int x)&#123;    int p=0;    for (int i = 30; ~i ; i -- )&#123;        int &amp;s=son[p][x&gt;&gt;i&amp;1];        if(!s) s=++idx;        p=s;    &#125;&#125;</code></pre><p>这里在定义s时，如果不加第一个引用（第二个&amp;是与操作，接下来会讲），只能代表son[p][x&gt;&gt;i&amp;1]中存储的数值，而在这里使用了引用 就相当于以下操作</p><pre><code class="language-c">void insert(int x)&#123;    int p=0;    for (int i = 30; ~i ; i -- )&#123;        int &amp;s=son[p][x&gt;&gt;i&amp;1];        if(!son[p][x&gt;&gt;i&amp;1]) son[p][x&gt;&gt;i&amp;1]=++idx;        p=son[p][x&gt;&gt;i&amp;1];    &#125;&#125;</code></pre><p>是不是很省代码！</p><h3 id="位操作中的与操作运算符"><a class="header-anchor" href="#位操作中的与操作运算符">¶</a><a href="https://so.csdn.net/so/search?q=%E4%BD%8D%E6%93%8D%E4%BD%9C&amp;spm=1001.2101.3001.7020">位操作</a>中的与操作运算符</h3><p>&amp;是单目运算符，按位与运算通常用来对某些位清0或保留某些位</p><p>计算的时候按位计算，&amp;两边操作数对应位上全为1时，结果的该位值为1。否则该位值为0</p><h3 id="逻辑与运算"><a class="header-anchor" href="#逻辑与运算">¶</a>逻辑与运算</h3><p>&amp;&amp;就是常说的and操作，双目运算符</p><p>逻辑运算结果只有0和1两种结果。 一般在&amp;&amp;两边是两个逻辑表达式。当两个表达式值均为1时，<br>&amp;&amp;运算结果为1，否则为0。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在做题时，经常会看到在数字或者字符串前面加上&amp;amp;，之前一直没太注意这个单目&amp;amp;，下面总结一下&amp;amp;的用法。😗&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="http://example.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="C/C++" scheme="http://example.com/tags/C-C/"/>
    
    <category term="others" scheme="http://example.com/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法详解</title>
    <link href="http://example.com/2022/08/27/KMP%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/08/27/KMP%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-08-27T06:15:37.460Z</published>
    <updated>2022-08-28T01:49:08.802Z</updated>
    
    <content type="html"><![CDATA[<p>几个月前学过一次kmp，因为太愚笨，没有搞明白暂时放弃了，这几天又开始看，终于搞明白了，再次记录一下我的理解😎</p><span id="more"></span><h3 id="BF算法-O-n-m"><a class="header-anchor" href="#BF算法-O-n-m">¶</a>BF算法 O(n*m)</h3><p><strong>模式匹配</strong>：子串的定位运算成为串的模式匹配或串匹配</p><blockquote><p>假设有两个串 S、T，设S为主串，也称正文串：T为子串，也称模式。在主串 S中查找<br>与模式 T相匹配的子串，如果查找成功，返回匹配的子串第一个字符在主串中的位置。<br>最笨的办法就是穷举所有 S的所有子串，判断是否与T匹配，该算法称为 BF ( Brute<br>Force）算法。</p></blockquote><p>BF算法的思想就是将目标串S的第一个字符与模式串T的第一个字符进行匹配，若相等，则继续比较S的第二个字符和T的第二个字符；若不相等，则比较S的第二个字符和T的第一个字符，依次比较下去，直到得出最后的匹配结果。</p><p>算法实现（C语言版本）</p><pre><code class="language-c">#include &lt;stdio.h&gt;#include&lt;string.h&gt;//strA是主串，strB是子串int mate(char *strA, char *strB) &#123;    int i, j;    i = j = 0;    while (i &lt; strlen(strA) &amp;&amp; j &lt; strlen(strB)) &#123;        if(strA[i]==strB[j])&#123;            i++;            j++;        &#125; else&#123;            i=i-j+1;            j=0;        &#125;    &#125;    //判断字串情况如果到最后则遍历完毕找到匹配位置    if(j== strlen(strB))&#123;        return i-j+1;    &#125;    return 0;&#125;</code></pre><p>可以看出 bf算法本身是没有什么技巧在的 就是简单的暴力枚举 故当数据范围比较大时 bf算法就不再适用</p><h3 id="改进的KMP算法"><a class="header-anchor" href="#改进的KMP算法">¶</a>改进的KMP算法</h3><p>实际上，完全没必要从S的每一个字符开始穷举每一种情况，某K，M，P名字开头的三位大佬对上述算法进行改进，并提出了KMP算法。</p><p>需要了解一些基本概念：</p><ol><li><p>s[ ]是模式串，即比较长的字符串。</p></li><li><p>p[ ]是模板串，即比较短的字符串。</p></li><li><p>前缀：从前往后取若干个字符。</p></li><li><p>后缀：从后往前取若干个字符。</p></li><li><p>部分匹配值：前缀和后缀的最长共有元素的长度。</p></li><li><p>next[ ]是“部分匹配值表”，即next数组，它存储的是每一个下标对应的“部分匹配值”，是<strong>KMP算法的核心</strong>。（后面作详细讲解）。</p></li></ol><p>核心思想：在每次失配时，不是把p串往后移一位，而是把p串往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找next[ ]数组确定的。</p><h4 id="next数组的含义："><a class="header-anchor" href="#next数组的含义：">¶</a>next数组的含义：</h4><p>对next[ j ] ，是p[ 1, j ]串中前缀和后缀相同的最大长度（部分匹配值），即 p[ 1, next[ j ] ] = p[ j - next[ j ] + 1, j ]。</p><p>如：</p><p>手动模拟求next数组：</p><p>对 p = “abcab”</p><table><thead><tr><th>p</th><th>a</th><th>b</th><th>c</th><th>a</th><th>b</th></tr></thead><tbody><tr><td>下标</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td>next[ ]</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td></tr></tbody></table><p>对next[ 1 ] ：前缀 = 空集—————后缀 = 空集—————next[ 1 ] = 0;</p><p>对next[ 2 ] ：前缀 = { a }—————后缀 = { b }—————next[ 2 ] = 0;</p><p>对next[ 3 ] ：前缀 = { a , ab }—————后缀 = { c , bc}—————next[ 3 ] = 0;</p><p>对next[ 4 ] ：前缀 = { a , ab , abc }—————后缀 = { a . ca , bca }—————next[ 4 ] = 1;</p><p>对next[ 5 ] ：前缀 = { a , ab , abc , abca }————后缀 = { b , ab , cab , bcab}————next[ 5 ] = 2;</p><h4 id="KMP主要分两步：求next数组、匹配字符串。"><a class="header-anchor" href="#KMP主要分两步：求next数组、匹配字符串。">¶</a>KMP主要分两步：求next数组、匹配字符串。</h4><p>先说一下如何求 next数组</p><p>next数组其实就是求模板串的相同前后缀的长度</p><p>算法实现：</p><pre><code class="language-c">for(int i = 2, j = 0; i &lt;= m; i++)&#123;    while(j &amp;&amp; p[i] != p[j+1]) j = next[j];    if(p[i] == p[j+1]) j++;        next[i] = j;&#125;</code></pre><p>可以写出通用公式</p><p>​{ 0 ,  j=1</p><p>next[j]=  { lmax+1 , T的相等前缀后缀的最大程度为lmax</p><p>​{ 1 , 没有相等前缀后缀</p><p>求匹配字符串</p><p>算法实现（c语言版本）</p><pre><code class="language-c">for(int i = 1, j = 0; i &lt;= n; i++)&#123;    while(j &amp;&amp; s[i] != p[j+1]) j = ne[j];    //如果j有对应p串的元素， 且s[i] != p[j+1], 则失配， 移动p串    //用while是由于移动后可能仍然失配，所以要继续移动直到匹配或整个p串移到后面（j = 0)    if(s[i] == p[j+1]) j++;    //当前元素匹配，j移向p串下一位    if(j == m)    &#123;        //匹配成功，进行相关操作        j = next[j];  //继续匹配下一个子串    &#125;&#125;</code></pre><p>将上述两个代码合并就是KMP算法的代码实现啦</p><pre><code class="language-c">for (int i = 2,j=0; i &lt;= n; i ++ )&#123;        while(j&amp;&amp;p[i]!=p[j+1]) j=ne[j];      if(p[i]==p[j+1]) j++;        ne[i]=j;&#125;for (int i = 1,j=0; i &lt;= m; i ++ )&#123;    while( j &amp;&amp; s[i]!= p[j+1]) j=ne[j];        if(s[i]==p[j+1]) j++;        if(j==n)&#123;        j=ne[j];                printf(&quot;%d &quot;,i-n);    &#125;&#125;</code></pre><h4 id="算法复杂度分析"><a class="header-anchor" href="#算法复杂度分析">¶</a>算法复杂度分析</h4><p>设S,T串的长度分别为n、m。KMP 算法的特点是：i不回退，当S[j]≠T[j]时，j回退<br>到next[j]，重新开始比较。最坏情况下扫描整个S串，其时间复杂度为 O（n)。计算next数<br>组需要扫描整个 工串，其时间复杂度为 0（m），因此总的时间复杂度为 O(n×m)。<br>需要注意的是，尽管 BF 算法最坏情况下时间复杂度为 O（n×m)，KMP 算法的时间复杂<br>度为 O(n×m)。但是在实际运用中，BF 算法的时间复杂度一般为 Q(n×m)，因此仍然有很多<br>地方用 BF 算法进行模式匹配。只有在主串和子串有很多部分匹配的情况下，KMP 才显得更<br>优越</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;几个月前学过一次kmp，因为太愚笨，没有搞明白暂时放弃了，这几天又开始看，终于搞明白了，再次记录一下我的理解😎&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="KMP" scheme="http://example.com/tags/KMP/"/>
    
    <category term="ALGO" scheme="http://example.com/tags/ALGO/"/>
    
  </entry>
  
  <entry>
    <title>vue3</title>
    <link href="http://example.com/2022/08/25/Vue3/"/>
    <id>http://example.com/2022/08/25/Vue3/</id>
    <published>2022-08-25T07:57:50.474Z</published>
    <updated>2022-08-27T12:13:03.755Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下学习vue框架时的知识点以及需要注意的小tips~ 🥰</p><span id="more"></span><h3 id="0-启动vue自带的图形化项目管理界面"><a class="header-anchor" href="#0-启动vue自带的图形化项目管理界面">¶</a>0.  启动<code>vue</code>自带的图形化项目管理界面</h3><p><code>vue ui</code><br>常见问题1：Windows上运行<code>vue</code>，提示无法加载文件，表示用户权限不足。<br>解决方案：用管理员身份打开终端，输入<code>set-ExecutionPolicy RemoteSigned</code>，然后输入<code>y</code></p><h3 id="1-基本概念"><a class="header-anchor" href="#1-基本概念">¶</a>1.   基本概念</h3><h4 id="script部分"><a class="header-anchor" href="#script部分">¶</a>script部分</h4><p><code>export default</code>对象的属性：</p><p><code>name</code>：组件的名称<br><code>components</code>：存储<code>&lt;template&gt;</code>中用到的所有组件<br><code>props</code>：存储父组件传递给子组件的数据<br><code>watch()</code>：当某个数据发生变化时触发<br><code>computed</code>：动态计算某个数据<br><code>setup(props, context)</code>：初始化变量、函数<br><code>ref</code>定义变量，可以用<code>.value</code>属性重新赋值<br><code>reactive</code>定义对象，不可重新赋值<br><code>props</code>存储父组件传递过来的数据<br><code>context.emit()</code>：触发父组件绑定的函数</p><ul><li><code>ref</code>定义变量，可以用.<code>value</code>属性重新赋值</li><li><code>reactive</code>定义对象，不可重新赋值</li><li><code>props</code>存储父组件传递过来的数据</li><li><code>context.emit()</code>：触发父组件绑定的函数</li></ul><h4 id="template部分"><a class="header-anchor" href="#template部分">¶</a>template部分</h4><p><code>&lt;slot&gt;&lt;/slot&gt;</code>：存放父组件传过来的<code>children</code>。<br><code>v-on:click</code>或<code>@click</code>属性：绑定事件<br><code>v-if</code>、<code>v-else</code>、<code>v-else-if</code>属性：判断<br><code>v-for</code>属性：循环，<code>:key</code>循环的每个元素需要有唯一的key<br><code>v-bind:</code>或<code>:：</code>绑定属性</p><h4 id="style部分"><a class="header-anchor" href="#style部分">¶</a>style部分</h4><p><code>&lt;style&gt;</code>标签添加<code>scope</code>属性后，不同组件间的css不会相互影响。</p><h4 id="第三方组件"><a class="header-anchor" href="#第三方组件">¶</a>第三方组件</h4><p><code>view-router</code>包：实现路由功能。<br><code>vuex</code>：存储全局状态，全局唯一。<br><code>state</code>: 存储所有数据，可以用<code>modules</code>属性划分成若干模块<br><code>getters</code>：根据state中的值计算新的值<br><code>mutations</code>：所有对<code>state</code>的修改操作都需要定义在这里，不支持异步，可以通过<code>$store.commit()</code>触发<br><code>actions</code>：定义对<code>state</code>的复杂修改操作，支持异步，可以通过<code>$store.dispatch()</code>触发。注意不能直接修改<code>state</code>，只能通过<code>mutations</code>修改<code>state</code>。<br><code>modules</code>：定义<code>state</code>的子模块</p><h3 id="2-常用API"><a class="header-anchor" href="#2-常用API">¶</a>2. 常用API</h3><h4 id="获取Json-Web-Token（JWT）"><a class="header-anchor" href="#获取Json-Web-Token（JWT）">¶</a>获取Json Web Token（JWT）</h4><ul><li><p>地址：<a href="https://app165.acapp.acwing.com.cn/api/token/">https://app165.acapp.acwing.com.cn/api/token/</a></p></li><li><p>方法：<code>POST</code></p></li><li><p>是否验证jwt：否</p></li><li><p>输入参数：</p><p>​<code>username</code>: 用户名</p><p>​<code>password</code>: 密码</p></li><li><p>返回结果：</p><p>​<code>access</code>: 访问令牌，有效期5分钟</p><p>​<code>refresh</code>: 刷新令牌，有效期14天</p></li></ul><h4 id="刷新JWT令牌"><a class="header-anchor" href="#刷新JWT令牌">¶</a>刷新JWT令牌</h4><ul><li><p>地址：<a href="https://app165.acapp.acwing.com.cn/api/token/refresh/">https://app165.acapp.acwing.com.cn/api/token/refresh/</a></p></li><li><p>方法：<code>POST</code></p></li><li><p>是否验证jwt：否</p></li><li><p>输入参数：</p><p>​<code>refresh</code>: 刷新令牌</p></li><li><p>返回结果：</p><p>​<code>access</code>: 访问令牌，有效期5分钟</p></li></ul><h4 id="获取用户列表"><a class="header-anchor" href="#获取用户列表">¶</a>获取用户列表</h4><ul><li>地址：<a href="https://app165.acapp.acwing.com.cn/myspace/userlist/">https://app165.acapp.acwing.com.cn/myspace/userlist/</a></li><li>方法：<code>GET</code></li><li>是否验证jwt：否</li><li>输入参数：无</li><li>返回结果：返回10个用户的信息</li></ul><h4 id="获取某个用户的信息"><a class="header-anchor" href="#获取某个用户的信息">¶</a>获取某个用户的信息</h4><ul><li><p>地址：<a href="https://app165.acapp.acwing.com.cn/myspace/getinfo/">https://app165.acapp.acwing.com.cn/myspace/getinfo/</a></p><p>​方法：<code>GET</code></p></li><li><p>是否验证jwt：是</p></li><li><p>输入参数：</p><p>​<code>user_id</code>：用户的ID</p></li><li><p>返回结果：该用户的信息</p></li></ul><h4 id="获取某个用户的所有帖子"><a class="header-anchor" href="#获取某个用户的所有帖子">¶</a>获取某个用户的所有帖子</h4><ul><li><p>地址：<a href="https://app165.acapp.acwing.com.cn/myspace/post/">https://app165.acapp.acwing.com.cn/myspace/post/</a></p></li><li><p>方法：<code>GET</code></p></li><li><p>是否验证jwt：是</p></li><li><p>输入参数：</p><p>​<code>user_id</code>：用户的ID</p></li><li><p>返回结果：该用户的所有帖子</p></li></ul><h4 id="创建一个帖子"><a class="header-anchor" href="#创建一个帖子">¶</a>创建一个帖子</h4><ul><li><p>地址：<a href="https://app165.acapp.acwing.com.cn/myspace/post/">https://app165.acapp.acwing.com.cn/myspace/post/</a></p></li><li><p>方法：<code>POST</code></p></li><li><p>是否验证jwt：是</p></li><li><p>输入参数：</p><p>​<code>content</code>：帖子的内容</p></li><li><p>返回结果：<code>result: success</code></p></li></ul><h4 id="删除一个帖子"><a class="header-anchor" href="#删除一个帖子">¶</a>删除一个帖子</h4><ul><li><p>地址：<a href="https://app165.acapp.acwing.com.cn/myspace/post/">https://app165.acapp.acwing.com.cn/myspace/post/</a></p></li><li><p>方法：<code>DELETE</code></p></li><li><p>是否验证jwt：是</p></li><li><p>输入参数：</p><p>​<code>post_id</code>：被删除帖子的ID</p></li><li><p>返回结果：<code>result: success</code></p></li></ul><h4 id="更改关注状态"><a class="header-anchor" href="#更改关注状态">¶</a>更改关注状态</h4><p>如果未关注，则关注；如果已关注，则取消关注。</p><ul><li><p>地址：<a href="https://app165.acapp.acwing.com.cn/myspace/follow/">https://app165.acapp.acwing.com.cn/myspace/follow/</a></p></li><li><p>方法：POST</p></li><li><p>是否验证jwt：是</p></li><li><p>输入参数：</p><p>​<code>target_id</code>: 被关注的用户ID</p></li><li><p>返回结果：<code>result: success</code></p></li></ul><h4 id="注册账号"><a class="header-anchor" href="#注册账号">¶</a>注册账号</h4><ul><li><p>地址：<a href="https://app165.acapp.acwing.com.cn/myspace/user/">https://app165.acapp.acwing.com.cn/myspace/user/</a></p></li><li><p>方法：<code>POST</code></p></li><li><p>是否验证jwt：否</p></li><li><p>输入参数：</p><p>​<code>username</code>: 用户名</p><p>​<code>password</code>：密码</p><p>​<code>password_confirm</code>：确认密码</p></li><li><p>返回结果：</p><p>​<code>result: success</code></p><p>​<code>result: 用户名和密码不能为空</code></p><p>​<code>result: 两个密码不一致</code></p><p>​<code>result: 用户名已存在</code></p></li></ul><h3 id="3-小知识点"><a class="header-anchor" href="#3-小知识点">¶</a>3 .小知识点</h3><ol><li><p>页面与组件之间信息进行交互时，setup里面要写props和context</p><blockquote><p>父组件向子组件传递信息用props，</p><p>子组件向父组件传递信息用context</p></blockquote></li></ol><p>2.所有的循环都需要绑定一个唯一的key属性</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下学习vue框架时的知识点以及需要注意的小tips~ 🥰&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="vue3" scheme="http://example.com/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/08/24/hello-world/"/>
    <id>http://example.com/2022/08/24/hello-world/</id>
    <published>2022-08-24T07:39:20.125Z</published>
    <updated>2022-08-28T01:48:16.368Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a class="header-anchor" href="#Quick-Start">¶</a>Quick Start</h2><h3 id="Create-a-new-post"><a class="header-anchor" href="#Create-a-new-post">¶</a>Create a new post</h3><pre><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a class="header-anchor" href="#Run-server">¶</a>Run server</h3><pre><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a class="header-anchor" href="#Generate-static-files">¶</a>Generate static files</h3><pre><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a class="header-anchor" href="#Deploy-to-remote-sites">¶</a>Deploy to remote sites</h3><pre><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="http://example.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="others" scheme="http://example.com/tags/others/"/>
    
  </entry>
  
</feed>
