<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Albatross&amp;blog</title>
  
  <subtitle>欢迎来到我的博客~</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-01-20T14:21:11.526Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Albatross</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go语言基础</title>
    <link href="http://example.com/2023/01/20/Go%E8%AF%AD%E8%A8%80/"/>
    <id>http://example.com/2023/01/20/Go%E8%AF%AD%E8%A8%80/</id>
    <published>2023-01-20T14:18:04.671Z</published>
    <updated>2023-01-20T14:21:11.526Z</updated>
    
    <content type="html"><![CDATA[<p>掘金系列课程学习笔记</p><span id="more"></span><p>Go是一门编译型语言，Go语言的工具链将源代码及其依赖转换成计算机的机器指令（静态编译）。</p><p>我们以经典的hello,world作为入门</p><pre><code class="language-go">package mainimport &quot;fmt&quot;func main() &#123;fmt.Println(&quot;hello world&quot;)&#125;</code></pre><p>Go语言的代码通过<strong>包</strong>（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。一个包由位于单个目录下的一个或多个.go源代码文件组成，目录定义包的作用。每个源文件都以一条<code>package</code>声明语句开始，这个例子里就是<code>package main</code>，表示该文件属于哪个包，紧跟着一系列导入（import）的包，之后是存储在这个文件里的程序语句。</p><p><code>main</code>包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在<code>main</code>里的<code>main</code> <em>函数</em> 也很特殊，它是整个程序执行时的入口。<code>main</code>函数所做的事情就是程序做的。当然了，<code>main</code>函数一般调用其它包里的函数完成很多工作</p><p>必须告诉编译器源文件需要哪些包，这就是跟随在<code>package</code>声明后面的<code>import</code>声明扮演的角色。hello world例子只用到了一个包，大多数程序需要导入多个包。</p><p>一个函数的声明由<code>func</code>关键字、函数名、参数列表、返回值列表（这个例子里的<code>main</code>函数参数列表和返回值都是空的）以及包含在大括号里的函数体组成。</p><p>Go语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。实际上，编译器会主动把特定符号后的换行符转换为分号，因此换行符添加的位置会影响Go代码的正确解析</p><p>Go语言在代码格式上采取了很强硬的态度。<code>gofmt</code>工具把代码格式化为标准格式（并且这个格式化的工具没有任何可以调整代码格式的参数)，并且<code>go</code>工具中的<code>fmt</code>子命令会对指定包，否则默认为当前目录中所有.go源文件应用<code>gofmt</code>命令。</p><h2 id="程序结构"><a class="header-anchor" href="#程序结构">¶</a>程序结构</h2><h3 id="命名"><a class="header-anchor" href="#命名">¶</a>命名</h3><p>Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。并且大小写敏感。</p><p>Go语言中类似if和switch的关键字有25个；关键字不能用于自定义名字，只能在特定语法结构中使用。</p><pre><code>break      default       func     interface   selectcase       defer         go       map         structchan       else          goto     package     switchconst      fallthrough   if       range       typecontinue   for           import   return      var</code></pre><p>此外，还有大约30多个预定义的名字，比如int和true等，主要对应内建的常量、类型和函数。</p><pre><code>内建常量: true false iota nil内建类型: int int8 int16 int32 int64          uint uint8 uint16 uint32 uint64 uintptr          float32 float64 complex128 complex64          bool byte rune string error内建函数: make len cap new append copy close delete          complex real imag          panic recover</code></pre><p>此外，Go语言程序员推荐使用驼峰式命名。</p><h3 id="声明与变量"><a class="header-anchor" href="#声明与变量">¶</a>声明与变量</h3><p>Go语言的声明有以下4种</p><ul><li><code>var</code>：变量</li><li><code>const</code>：常量</li><li><code>type</code>：类型</li><li><code>func</code>：函数实体对象的声明</li></ul><h4 id="使用var进行声明"><a class="header-anchor" href="#使用var进行声明">¶</a>使用var进行声明</h4><p>变量可以这样进行声明</p><p><code>var 变量名 类型 = 表达式</code></p><p>其中<strong>类型</strong>或者<strong>表达式</strong>可以省略其一，因为不管是省略前者还是后者，Go语言都有他自己的方法。</p><p><strong>省略类型信息</strong></p><p>类型信息会根据其表达式对类型进行推导</p><p><strong>省略表达式</strong></p><p>如果是数值类型变量，那么将被声明为0（int =&gt; 0）</p><p>如果是布尔类型变量，那么将被声明为0（bool =&gt; false）</p><p>如果是字符串类型变量，那么将被声明为0（string =&gt; “”）</p><p>如果是接口或引用类型变量，那么将被声明为0（slice，map，chan，指针，函数 =&gt; nil）</p><h4 id="简短变量声明语句"><a class="header-anchor" href="#简短变量声明语句">¶</a>简短变量声明语句</h4><p>在函数内部，还有一种声明</p><p><code>名字 := 表达式</code></p><p>因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。var形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。</p><pre><code class="language-go">package mainimport (&quot;fmt&quot;&quot;math&quot;)func main() &#123;var a = &quot;initial&quot;var b, c int = 1, 2var d = truevar e float64//0f := float32(e)//0g := a + &quot;foo&quot;fmt.Println(a, b, c, d, e, f) // initial 1 2 true 0 0fmt.Println(g)                // initialappleconst s string = &quot;constant&quot;const h = 500000000const i = 3e20 / hfmt.Println(s, h, i, math.Sin(h), math.Sin(i))    //constant 500000000 6e+11 -0.28470407323754404 0.7591864109375384&#125;</code></pre><p>在我看来，go更像是Python和C语言的结合，语法相似，基础语法理解起来并不难，性能强大，并且很多功能都类似，比如C/C++特色的指针，这里也有类似的体现</p><p>如果用“var x int”声明语句声明一个x变量，那么&amp;x表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是<code>*int</code>，指针被称之为“指向int类型的指针”。</p><p>如果指针名字为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。同时<code>*p</code>表达式对应p指针指向的变量的值。一般<code>*p</code>表达式读取指针指向的变量的值，这里为int类型的值，同时因为<code>*p</code>对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。</p><pre><code class="language-Go">x := 1p := &amp;x         // p, of type *int, points to xfmt.Println(*p) // &quot;1&quot;*p = 2          // equivalent to x = 2fmt.Println(x)  // &quot;2&quot;</code></pre><h4 id="new函数"><a class="header-anchor" href="#new函数">¶</a>new函数</h4><p>表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为<code>*T</code>。</p><p>new函数类似一个语法糖，并且每次调用都会返回一个新的地址</p><pre><code class="language-Go">p := new(int)   // p, *int 类型, 指向匿名的 int 变量fmt.Println(*p) // &quot;0&quot;*p = 2          // 设置 int 匿名变量的值为 2fmt.Println(*p) // &quot;2&quot;</code></pre><h3 id="基础数据类型"><a class="header-anchor" href="#基础数据类型">¶</a>基础数据类型</h3><p>类C，其中常见到的8,16,32,64指的是8,16,32,64bit大小的有符号整数</p><h3 id="复合数据类型"><a class="header-anchor" href="#复合数据类型">¶</a>复合数据类型</h3><h4 id="数组"><a class="header-anchor" href="#数组">¶</a>数组</h4><p>在数组字面值中，如果在数组的长度位置出现的是“…”省略号，则表示数组的长度是根据初始化值的个数来计算。</p><pre><code class="language-Go">//初始化1var q [3]int = [3]int&#123;1, 2, 3&#125;//初始化2q := [...]int&#123;1, 2, 3&#125;fmt.Printf(&quot;%T\n&quot;, q) // &quot;[3]int&quot;</code></pre><h4 id="Slice"><a class="header-anchor" href="#Slice">¶</a>Slice</h4><p>Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作[]T，其中T代表slice中元素的类型；slice的语法和数组很像，只是没有固定长度而已，会进行自动扩容操作，每一次容量的变化都会导致重新分配内存和copy操作。</p><pre><code class="language-Go">//初始化var runes []rune//使用range来遍历，对于数组会返回两个值 第一个是下标 第二个是数值 如果不需要索引可以用_for _, r := range &quot;Hello, 世界&quot; &#123;    //append(原数组,...) 可以追加多个数    runes = append(runes, r)&#125;fmt.Printf(&quot;%q\n&quot;, runes) // &quot;['H' 'e' 'l' 'l' 'o' ',' ' ' '世' '界']&quot;//内置的make函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。s := make([]string, 3)</code></pre><h4 id="map"><a class="header-anchor" href="#map">¶</a>map</h4><p>无序的key/value对的集合，其中所有的key都是不同的</p><pre><code>//创建方式m1 := make(map[string]int)//赋值方式m1[&quot;one&quot;] = 1m1[&quot;two&quot;] = 2m2 := map[string]int&#123;&quot;one&quot;: 1, &quot;two&quot;: 2&#125;var m3 = map[string]int&#123;&quot;one&quot;: 1, &quot;two&quot;: 2&#125;//删除数据delete(m1, &quot;one&quot;)fmt.Println(m) //map[two:2]</code></pre><p>而且<code>x += y</code>和<code>x++</code>等简短赋值语法也可以用在map上</p><pre><code class="language-Go">ages[&quot;bob&quot;] += 1 ages[&quot;bob&quot;]++</code></pre><p>但是map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作</p><h4 id="结构体"><a class="header-anchor" href="#结构体">¶</a>结构体</h4><pre><code class="language-Go">//声明type Employee struct &#123;    ID        int    Name      string    DoB       time.Time    Salary    int    Position  string&#125;//声明了一个Employee类型的变量dilbertvar dilbert Employee//dilbert结构体变量的成员可以通过点操作符访问和赋值dilbert.Salary -= 5000 //或者是对成员取地址，然后通过指针访问position := &amp;dilbert.Position*position = &quot;Senior &quot; + *position </code></pre><h3 id="JSON"><a class="header-anchor" href="#JSON">¶</a>JSON</h3><pre><code class="language-go">package mainimport (   &quot;encoding/json&quot;   &quot;fmt&quot;)type userInfo struct &#123;   Name  string   Age   int `json:&quot;age&quot;`//该步骤可以更改json中的名称   Hobby []string&#125;func main() &#123;   a := userInfo&#123;Name: &quot;wang&quot;, Age: 18, Hobby: []string&#123;&quot;Golang&quot;, &quot;TypeScript&quot;&#125;&#125;   buf, err := json.Marshal(a)   if err != nil &#123;      panic(err)   &#125;   fmt.Println(buf)         //16进制编码 [123 34 78 97...]   fmt.Println(string(buf)) // &#123;&quot;Name&quot;:&quot;wang&quot;,&quot;age&quot;:18,&quot;Hobby&quot;:[&quot;Golang&quot;,&quot;TypeScript&quot;]&#125;   buf, err = json.MarshalIndent(a, &quot;&quot;, &quot;\t&quot;)   if err != nil &#123;      panic(err)   &#125;   fmt.Println(string(buf))   var b userInfo    //反序列化   err = json.Unmarshal(buf, &amp;b)   if err != nil &#123;      panic(err)   &#125;   fmt.Printf(&quot;%#v\n&quot;, b) // main.userInfo&#123;Name:&quot;wang&quot;, Age:18, Hobby:[]string&#123;&quot;Golang&quot;, &quot;TypeScript&quot;&#125;&#125;&#125;</code></pre><h3 id="函数"><a class="header-anchor" href="#函数">¶</a>函数</h3><pre><code class="language-go">//后置数据类型func add2(a, b int) int &#123;   return a + b&#125;//习惯于第一个是真正的返回值，第二个返回值是错误func exists(m map[string]string, k string) (v string, ok bool) &#123;   v, ok = m[k]   return v, ok&#125;</code></pre><h3 id="错误处理"><a class="header-anchor" href="#错误处理">¶</a>错误处理</h3><p>使用一个单目的返回值来传递错误信息，go语言的错误处理（使用if处理）能够及时处理，并且能够很清晰的知道哪个函数出错了</p><pre><code class="language-go">package mainimport (   &quot;errors&quot;   &quot;fmt&quot;)type user struct &#123;   name     string   password string&#125;func findUser(users []user, name string) (v *user, err error) &#123;   for _, u := range users &#123;      if u.name == name &#123;         return &amp;u, nil      &#125;   &#125;   return nil, errors.New(&quot;not found&quot;)&#125;func main() &#123;   u, err := findUser([]user&#123;&#123;"wang", "1024"&#125;&#125;, &quot;wang&quot;)   if err != nil &#123;      fmt.Println(err)      return   &#125;   fmt.Println(u.name) // wang   if u, err := findUser([]user&#123;&#123;"wang", "1024"&#125;&#125;, &quot;li&quot;); err != nil &#123;      fmt.Println(err) // not found      return   &#125; else &#123;      fmt.Println(u.name)   &#125;&#125;</code></pre><h3 id="字符串操作"><a class="header-anchor" href="#字符串操作">¶</a>字符串操作</h3><pre><code class="language-go">package mainimport (   &quot;fmt&quot;   &quot;strings&quot;)func main() &#123;   a := &quot;hello&quot;   fmt.Println(strings.Contains(a, &quot;ll&quot;))                // true   fmt.Println(strings.Count(a, &quot;l&quot;))                    // 2   fmt.Println(strings.HasPrefix(a, &quot;he&quot;))               // true   fmt.Println(strings.HasSuffix(a, &quot;llo&quot;))              // true   fmt.Println(strings.Index(a, &quot;ll&quot;))                   // 2   fmt.Println(strings.Join([]string&#123;&quot;he&quot;, &quot;llo&quot;&#125;, &quot;-&quot;)) // he-llo   fmt.Println(strings.Repeat(a, 2))                     // hellohello   fmt.Println(strings.Replace(a, &quot;e&quot;, &quot;E&quot;, -1))         // hEllo   fmt.Println(strings.Split(&quot;a-b-c&quot;, &quot;-&quot;))              // [a b c]   fmt.Println(strings.ToLower(a))                       // hello   fmt.Println(strings.ToUpper(a))                       // HELLO   fmt.Println(len(a))                                   // 5   b := &quot;你好&quot;   fmt.Println(len(b)) // 6&#125;</code></pre><p>字符串格式化</p><pre><code class="language-go">package mainimport &quot;fmt&quot;type point struct &#123;   x, y int&#125;func main() &#123;   s := &quot;hello&quot;   n := 123   p := point&#123;1, 2&#125;   fmt.Println(s, n) // hello 123   fmt.Println(p)    // &#123;1 2&#125;   fmt.Printf(&quot;s=%v\n&quot;, s)  // s=hello   fmt.Printf(&quot;n=%v\n&quot;, n)  // n=123   fmt.Printf(&quot;p=%v\n&quot;, p)  // p=&#123;1 2&#125;    //+v 查看较为详细的结构   fmt.Printf(&quot;p=%+v\n&quot;, p) // p=&#123;x:1 y:2&#125;    //#v 更加详细   fmt.Printf(&quot;p=%#v\n&quot;, p) // p=main.point&#123;x:1, y:2&#125;   f := 3.141592653   fmt.Println(f)          // 3.141592653   fmt.Printf(&quot;%.2f\n&quot;, f) // 3.14&#125;</code></pre><h3 id="时间处理"><a class="header-anchor" href="#时间处理">¶</a>时间处理</h3><pre><code class="language-go">package mainimport (   &quot;fmt&quot;   &quot;time&quot;)func main() &#123;   now := time.Now()   fmt.Println(now) // 2022-03-27 18:04:59.433297 +0800 CST m=+0.000087933   t := time.Date(2022, 3, 27, 1, 25, 36, 0, time.UTC)   t2 := time.Date(2022, 3, 27, 2, 30, 36, 0, time.UTC)   fmt.Println(t)                               // 2022-03-27 01:25:36 +0000 UTC   fmt.Println(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute()) // 2022 March 27 1 25   fmt.Println(t.Format(&quot;2006-01-02 15:04:05&quot;))                    // 2022-03-27 01:25:36      //截取时间   diff := t2.Sub(t)   fmt.Println(diff)                           // 1h5m0s   fmt.Println(diff.Minutes(), diff.Seconds()) // 65 3900   t3, err := time.Parse(&quot;2006-01-02 15:04:05&quot;, &quot;2022-03-27 01:25:36&quot;)   if err != nil &#123;      panic(err)   &#125;   //比较的结果是值而不是地址   fmt.Println(t3 == t)    // true           //获取时间戳   fmt.Println(now.Unix()) // 1648738080&#125;</code></pre><h3 id="数字解析"><a class="header-anchor" href="#数字解析">¶</a>数字解析</h3><pre><code class="language-go">package mainimport (   &quot;fmt&quot;   &quot;strconv&quot;)func main() &#123;   //字符串 =&gt; 数字   f, _ := strconv.ParseFloat(&quot;1.234&quot;, 64)   fmt.Println(f) // 1.234    //10进制，64位   n, _ := strconv.ParseInt(&quot;111&quot;, 10, 64)   fmt.Println(n) // 111    //0代表自动推测进制    n, _ = strconv.ParseInt(&quot;0x1000&quot;, 0, 64)   fmt.Println(n) // 4096   n2, _ := strconv.Atoi(&quot;123&quot;)   fmt.Println(n2) // 123   n2, err := strconv.Atoi(&quot;AAA&quot;)   fmt.Println(n2, err) // 0 strconv.Atoi: parsing &quot;AAA&quot;: invalid syntax&#125;</code></pre><h3 id="进程信息"><a class="header-anchor" href="#进程信息">¶</a>进程信息</h3><pre><code class="language-go">package mainimport (   &quot;fmt&quot;   &quot;os&quot;   &quot;os/exec&quot;)func main() &#123;   //该过程需要像Args中传入参数   // go run example/20-env/main.go a b c d   fmt.Println(os.Args)           // [/var/folders/8p/n34xxfnx38dg8bv_x8l62t_m0000gn/T/go-build3406981276/b001/exe/main a b c d]      //分别来获取和写入环境变量     fmt.Println(os.Getenv(&quot;PATH&quot;)) // /usr/local/go/bin...   fmt.Println(os.Setenv(&quot;AA&quot;, &quot;BB&quot;))   //启动子进程和获取输入输出   buf, err := exec.Command(&quot;grep&quot;, &quot;127.0.0.1&quot;, &quot;/etc/hosts&quot;).CombinedOutput()   if err != nil &#123;      panic(err)   &#125;   fmt.Println(string(buf)) // 127.0.0.1       localhost&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;掘金系列课程学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="语言学习" scheme="http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="others" scheme="http://example.com/tags/others/"/>
    
    <category term="GO" scheme="http://example.com/tags/GO/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记（3）-函数（3）</title>
    <link href="http://example.com/2022/10/22/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89-%E5%87%BD%E6%95%B0%EF%BC%883%EF%BC%89/"/>
    <id>http://example.com/2022/10/22/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89-%E5%87%BD%E6%95%B0%EF%BC%883%EF%BC%89/</id>
    <published>2022-10-22T13:23:19.216Z</published>
    <updated>2022-10-22T15:46:13.841Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学py，简单记录一下笔记</p><span id="more"></span><h3 id="内置函数-部分常用"><a class="header-anchor" href="#内置函数-部分常用">¶</a>内置函数(部分常用)</h3><h4 id="生成器和迭代相关"><a class="header-anchor" href="#生成器和迭代相关">¶</a>生成器和迭代相关</h4><h5 id="next和iter"><a class="header-anchor" href="#next和iter">¶</a>next和iter</h5><p>在之前学过迭代器，其实<code>next</code>和<code>iter</code>用法可以等价为</p><pre><code class="language-python">lst = [11,22,33]it  = lst._iter_()it = iter(lst)print(it._next_())print(next(it))</code></pre><h4 id="帮助函数"><a class="header-anchor" href="#帮助函数">¶</a>帮助函数</h4><h5 id="callable"><a class="header-anchor" href="#callable">¶</a>callable</h5><p>用于判断函数时候能被调用</p><pre><code class="language-python">def func():passprint(callable(func))#Trueprint(callable(123))#False</code></pre><p>可以用于判断出创建的函数能否被调用</p><h5 id="id"><a class="header-anchor" href="#id">¶</a>id</h5><p>查看不可变数据类型的哈希值</p><h4 id="编译"><a class="header-anchor" href="#编译">¶</a>编译</h4><h5 id="eval和exec"><a class="header-anchor" href="#eval和exec">¶</a>eval和exec</h5><p>都可以将字符串的代码给动态执行</p><p>区别：<code>eval</code>有返回值<code>exec</code>无返回值</p><pre><code class="language-python">s = &quot;1+1&quot;print(eval(s)) #2s = &quot;a = 100&quot;exec(s)print(a) #如果使用pycharm会报错 但是实际上是可以运行的 输出的结果是100 </code></pre><p><code>eval</code>还可以把字符串当成代码执行</p><pre><code class="language-python">s = &quot;[1,2,3]&quot;lst = eval(s)print(lst,type(lst)) #[1, 2, 3] &lt;class 'list'&gt;</code></pre><p>会存在安全隐患，因为输入的数据不可判断，可能会造成程序异常等其他隐患</p><pre><code class="language-python">s = input(&quot;请输入你要执行的代码:&quot;)exec(s)print(&quot;hello world&quot;)</code></pre><h5 id="compile"><a class="header-anchor" href="#compile">¶</a>compile</h5><p><code>compile()</code> 把一段代码串加载，后面可以通过<code>eval</code>和<code>exec</code>去执行</p><p>第一个参数为你想要执行的代码</p><p>第二个参数为代码类型 如果为实际的代码就不需要在空字串里面添加东西了，如果是文件，这需要加上文件，但是第一个参数要为空</p><p>第三个参数为执行的模式，可以写eval(只是运行代码)，exec(运行代码并且有返回值)或者single（如果代码中有交互的，如<code>input</code>）</p><pre><code>c1 = compile(&quot;for i in range(10):print(i)&quot;,&quot;&quot;,&quot;exec&quot;)c2 = complie(&quot;n = int(input('输入数字:'))&quot;,&quot;&quot;,&quot;single&quot;)print(n)</code></pre><h4 id="进制转换"><a class="header-anchor" href="#进制转换">¶</a>进制转换</h4><p><code>bin</code> 2进制</p><pre><code class="language-python">print(bin(5))#0b101</code></pre><p><code>oct</code> 8进制</p><p><code>hex</code>16进制</p><h4 id="数学"><a class="header-anchor" href="#数学">¶</a>数学</h4><p><code>abs</code> 绝对值</p><p><code>divmod</code> 除法</p><p><code>round</code> 四舍五入</p><p><code>pow</code>次幂</p><p><code>sum</code>求和，对象必须是可迭代对象</p><p><code>max，min</code>  最大值最小值</p><h4 id="数据结构"><a class="header-anchor" href="#数据结构">¶</a>数据结构</h4><p><code>frozenset</code> 不能进行增删改的集合</p><p><code>enumerate</code> 用来迭代对象时，既能得到该对象的下标，又能得到对象的值</p><pre><code class="language-python">lst = [&quot;好想&quot;,&quot;解封&quot;]for i,item in enumerate(lst):print(item)#0 好想#1 解封</code></pre><p><code>or</code>相当于或</p><p><code>and</code>相当于且</p><p>两个函数里面都需要用可迭代对象来对其进行判断</p><pre><code class="language-python">lst = [0 ,&quot;所有&quot;, True]print(any(lst))#Trueprint(all(lst))#False</code></pre><p><code>zip</code> 拉链函数 将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表</p><pre><code class="language-python">a = [1,2,3]b = [4,5,6]c = [4,5,6,7,8]zipped = zip(a,b)     # 返回一个对象print(zipped)#&lt;zip object at 0x103abc288&gt;print(list(zipped))  # list() 转换为列表#[(1, 4), (2, 5), (3, 6)]print(list(zip(a,c)))    # 元素个数与最短的列表一致#[(1, 4), (2, 5), (3, 6)]a1, a2 = zip(*zip(a,b))          # 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式print(list(a1))#[1, 2, 3]print(list(a2))#[4, 5, 6]</code></pre><p>一个很好用的方法 构建字典</p><pre><code class="language-python">d = dict(zip(lst1,lst2))</code></pre><p><code>slice</code>切片函数</p><pre><code class="language-python">s = &quot;今天天气不错&quot;ss = slice(1,6,2)#步长为2s1 = s[ss]print(s1)#天气错</code></pre><p><code>ord</code> 将字符转换为对应的数字</p><p><code>chr</code>  将数字变成字符</p><pre><code class="language-python">print(ord(&quot;福&quot;)) #31119print(chr(31119))</code></pre><p><code>chr</code>还能用于生成验证码</p><pre><code class="language-python">n = random.randint(65,97)#给出范围print(chr(n))</code></pre><p><code>ascii</code>在ASCII范围内的符号还是原字符，若不再这打印<code>utf-8</code>编码符</p><p><code>repr</code>一个字符串最应该表现的效果，有些转义字符比如<code>\t</code>，正常输出不会输出，但是使用<code>repr</code>可以将其输出</p><p>r字符串  当字符串中出现转义字符，但是有不想使用转义字符的效果，可以这样写</p><pre><code class="language-python">print(r&quot;今天天\t气\n很\好&quot;)#今天天\t气\n很\好</code></pre><h5 id="format"><a class="header-anchor" href="#format">¶</a>format</h5><p>基本语法是通过 <strong>{}</strong> 和 <strong>:</strong> 来代替以前的 <strong>%</strong> 。</p><p>format 函数可以接受不限个参数，位置可以不按顺序</p><pre><code class="language-python">print(&quot;&#123;&#125; &#123;&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;))  # 不设置指定位置，按默认顺序print(&quot;&#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;))  # 设置指定位置print( &quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;) ) # 设置指定位置</code></pre><p>也可以用来指定位数</p><pre><code class="language-python">a = 48print(format(a,&quot;08d&quot;))#00000048#d代表整数，8代表指定位数，凑不够用0补齐b = 1.23print(format(b,&quot;.3f&quot;)) #1.230#也可应用于浮点数</code></pre><h5 id="sorted"><a class="header-anchor" href="#sorted">¶</a>sorted</h5><p><strong>排序函数.</strong></p><p>语法: <code>sorted(Iterable, key=None, reverse=False)</code></p><p>​     <code>Iterable</code>: 可迭代对象</p><p>​     <code>key</code>: 排序规则(排序函数), 在sorted内部会将可迭代对象中的每一个元素传递给这个函数的参数. 根据函数运算的结果进行排序</p><p>​     <code>reverse</code>: 是否是倒叙. True: 倒叙, False: 正序</p><pre><code class="language-python">lst = [1,5,3,4,6]lst2 = sorted(lst)print(lst)  # 原列表不会改变print(lst2) # 返回的新列表是经过排序的</code></pre><p>和函数组合使用</p><pre><code class="language-python"># 根据字符串长度进行排序lst = [&quot;麻花藤&quot;, &quot;冈本次郎&quot;, &quot;中央情报局&quot;, &quot;狐仙&quot;]# 计算字符串长度def func(s):    return len(s)print(sorted(lst, key=func))</code></pre><p>和lambda组合使用</p><pre><code class="language-python"># 根据字符串长度进行排序lst = [&quot;麻花藤&quot;, &quot;冈本次郎&quot;, &quot;中央情报局&quot;, &quot;狐仙&quot;]# 计算字符串长度def func(s):    return len(s)print(sorted(lst, key=lambda s: len(s)))lst = [&#123;&quot;id&quot;:1, &quot;name&quot;:'盖伦', &quot;age&quot;:18&#125;,       &#123;&quot;id&quot;:2, &quot;name&quot;:'杰斯', &quot;age&quot;:16&#125;,       &#123;&quot;id&quot;:3, &quot;name&quot;:'压缩', &quot;age&quot;:17&#125;]# 按照年龄对学生信息进行排序print(sorted(lst, key=lambda e: e['age']))</code></pre><h5 id="map-v2"><a class="header-anchor" href="#map-v2">¶</a>map</h5><p>映射函数</p><p>语法: <code>map(function, iterable)</code> 可以对可迭代对象中的每一个元素进行映射. 分别取执行function</p><p>计算列表中每个元素的平方 ,返回新列表，如果直接输出，返回的是迭代对象的地址</p><pre><code class="language-python">def func(e):    return e*emp = map(func, [1, 2, 3, 4, 5])print(mp)print(list(mp))    改写成lambdaprint(list(map(lambda x: x * x, [1, 2, 3, 4, 5])))    计算两个列表中相同位置的数据的和# 计算两个列表相同位置的数据的和lst1 = [1, 2, 3, 4, 5]lst2 = [2, 4, 6, 8, 10]print(list(map(lambda x, y: x+y, lst1, lst2)))</code></pre><h5 id="filter"><a class="header-anchor" href="#filter">¶</a>filter</h5><p>筛选函数</p><p>语法: <code>filter(function. Iterable)</code></p><p>​     <code>function</code>: 用来筛选的函数. 在filter中会自动的把<code>iterable</code>中的元素传递给<code>function</code>. 然后根据<code>function</code>返回的True或者False来判断是否保留此项数据</p><p>​     <code>Iterable</code>: 可迭代对象</p><h4 id="三元表达式"><a class="header-anchor" href="#三元表达式">¶</a>三元表达式</h4><p>各大语言都有三元表达式. 目的是把简单的if判断写成一行.</p><p>语法:</p><p>结果1 if 条件 else 结果2</p><p>过程:</p><p>判断条件是否为真, 如果真, 返回结果1, 否则返回结果2</p><pre><code class="language-python">a = input(&quot;&gt;&gt;&gt;&quot;)b = input(&quot;&gt;&gt;&gt;&quot;)c = a if a &gt; b else bprint(c)</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在学py，简单记录一下笔记&lt;/p&gt;</summary>
    
    
    
    <category term="语言学习" scheme="http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="PYTHON" scheme="http://example.com/tags/PYTHON/"/>
    
  </entry>
  
  <entry>
    <title>配置git环境与项目搭建</title>
    <link href="http://example.com/2022/10/17/%E9%85%8D%E7%BD%AEgit%E7%8E%AF%E5%A2%83%E4%B8%8E%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA(vue+SpringBoot)/"/>
    <id>http://example.com/2022/10/17/%E9%85%8D%E7%BD%AEgit%E7%8E%AF%E5%A2%83%E4%B8%8E%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA(vue+SpringBoot)/</id>
    <published>2022-10-17T15:43:25.273Z</published>
    <updated>2022-10-18T01:55:12.750Z</updated>
    
    <content type="html"><![CDATA[<p>配置git环境与项目搭建(vue+SpringBoot)</p><span id="more"></span><h3 id="仓库项目配置"><a class="header-anchor" href="#仓库项目配置">¶</a>仓库项目配置</h3><h4 id="git仓库初始化"><a class="header-anchor" href="#git仓库初始化">¶</a>git仓库初始化</h4><p>鼠标右键<code>git bash</code></p><p>输入<code>git init</code>(可以通过<code>ls -a</code>查看是否初始化成功)</p><p>（<code>git status</code>：查看当前分支的情况,这里的情况大致分为三种对应git的三个区域(应该是三种情况)<br>这里我们发现,<code>readme.md</code>没有<code> add commit</code>,然后它提示<code>git add to track</code>）可选可不选</p><p><code>git add .</code>(将文件放入暂存区,第二个区域)，可用来添加也可以用来删除</p><p><code>git status</code>：查看此时文件的状态</p><p><code>git commit -m &quot;创建项目&quot;</code>(将暂存区提交到本地仓库)</p><h4 id="关于readme文件"><a class="header-anchor" href="#关于readme文件">¶</a>关于readme文件</h4><p>创建md文件：<code>touch readme.md</code></p><p>写入文件内容<code>vim readme.md</code><br>书写（插入）内容：按下 <code>i</code></p><p>书写完后：<code>esc</code>之后按<code>:</code>,输入<code>wq</code>实现保存和退出</p><p>之后再github\gitee\acgit 上创建云端仓库</p><h3 id="IDEA"><a class="header-anchor" href="#IDEA">¶</a>IDEA</h3><h4 id="创建项目"><a class="header-anchor" href="#创建项目">¶</a>创建项目</h4><p>挂了梯子连接外网还挺快的</p><p>提供两种连接方式：</p><p><code>https://start.spring.io/</code></p><p><code>https://start.aliyun.com</code></p><p>其他该勾选的勾选一下 改改名字</p><p><img src="/images/idea%E9%85%8D%E7%BD%AE1.png" alt="image-20221017211607398"></p><p>添加相关依赖</p><p><img src="/images/idea%E9%85%8D%E7%BD%AE2.png" alt="image-20221017211209643"></p><h4 id="启动项目"><a class="header-anchor" href="#启动项目">¶</a>启动项目</h4><p>启动项目,输入<code>127.0.0.1:8080</code>进行访问,如图即成功</p><p><img src="/images/idea%E9%85%8D%E7%BD%AE3.png" alt="image-20221017221244655"></p><h3 id="VUE"><a class="header-anchor" href="#VUE">¶</a>VUE</h3><p>在终端输入<code>vue ui</code>打开vue的界面选择创建一个新的vue项目</p><p>依赖添加：<code>jquery</code>，<code>bootstrap</code></p><p>插件添加：<code>vue-rooter</code>，<code>vue x</code></p><h3 id="APP"><a class="header-anchor" href="#APP">¶</a>APP</h3><p>在终端输入<code>vue ui</code>打开vue的界面选择创建一个新的vue项目</p><p>插件添加：<code>vue x</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;配置git环境与项目搭建(vue+SpringBoot)&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="JAVASCRIPT" scheme="http://example.com/tags/JAVASCRIPT/"/>
    
    <category term="vue3" scheme="http://example.com/tags/vue3/"/>
    
    <category term="other" scheme="http://example.com/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>简易拳皇项目</title>
    <link href="http://example.com/2022/10/15/%E7%AE%80%E6%98%93%E6%8B%B3%E7%9A%87%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/10/15/%E7%AE%80%E6%98%93%E6%8B%B3%E7%9A%87%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</id>
    <published>2022-10-15T15:51:31.917Z</published>
    <updated>2022-10-17T15:43:50.945Z</updated>
    
    <content type="html"><![CDATA[<p>简易拳皇项目笔记</p><span id="more"></span><p>主要用于练习HTML，CSS和JS</p><p>原理：利用每秒画面的刷新频率，来不断移动某处画面，从而达到人的视觉上看到真的在移动的动画</p><p>整个项目定义为一个class，</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简易拳皇项目笔记&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="JAVASCRIPT" scheme="http://example.com/tags/JAVASCRIPT/"/>
    
    <category term="other" scheme="http://example.com/tags/other/"/>
    
    <category term="游戏" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>一些JS知识点</title>
    <link href="http://example.com/2022/10/13/%E4%B8%80%E4%BA%9BJS%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://example.com/2022/10/13/%E4%B8%80%E4%BA%9BJS%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2022-10-13T11:32:28.972Z</published>
    <updated>2022-10-18T01:05:42.002Z</updated>
    
    <content type="html"><![CDATA[<p>随便记录一下学习记录</p><span id="more"></span><h2 id="一些JS知识点"><a class="header-anchor" href="#一些JS知识点">¶</a>一些JS知识点</h2><ul><li><p>求反三位数s=后面的是左上角波浪线，并用${}表示变量赋值</p><p><img src="https://api2.mubu.com/v3/document_image/1a8c8e99-b86b-42a1-8ba2-7dc8bb0e30bd-16325876.jpg" alt="image"></p></li><li><p>有15位有效数字</p></li><li><p>若要输出函数的返回值，且该函数没有返回值，则会输出undefined</p></li><li><p>数组下标没有越界一说，输出的结果是undefined</p></li><li><p>map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。<img src="C:%5CUsers%5Casus%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20221012154813526.png" alt="image-20221012154813526"></p></li><li><p>箭头函数(=&gt;)<img src="https://api2.mubu.com/v3/document_image/e738f1b8-390f-46f7-acfe-d4e55a8ca4f0-16325876.jpg" alt="image"><img src="https://api2.mubu.com/v3/document_image/11ffd4af-600b-4cb9-b615-d19efbb5e6fb-16325876.jpg" alt="image"><img src="https://api2.mubu.com/v3/document_image/4ac36566-8951-4ce8-b449-06af6f3ff8b2-16325876.jpg" alt="image"></p></li><li><p>标准输入输出</p><pre><code class="language-javascript">let buf = &quot;&quot;;process.stdin.on(&quot;readable&quot;, function()&#123;    //从缓冲区里面读数   let chunk = process.stdin.read();    //只要缓冲区有值，就转化为字符串添加到buf尾   if (chunk) buf += chunk.toString();&#125;);//读入操作结束后进行该函数process.stdin.on(&quot;end&quot;,function()&#123;   //函数体内进行要进行的操作&#125;);</code></pre></li><li><p>格式化输出 需要用左上方的波浪线</p></li><li><p>保留几位小数输出</p><p><img src="C:%5CUsers%5Casus%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20221013152433546.png" alt="image-20221013152433546">保留几位就在<code>toFixed()</code>的括号中填入几</p></li><li><p><code>javascript</code>代码运行没有编译的过程</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;随便记录一下学习记录&lt;/p&gt;</summary>
    
    
    
    <category term="语言学习" scheme="http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="others" scheme="http://example.com/tags/others/"/>
    
    <category term="JAVASCRIPT" scheme="http://example.com/tags/JAVASCRIPT/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="http://example.com/2022/10/12/JavaScript/"/>
    <id>http://example.com/2022/10/12/JavaScript/</id>
    <published>2022-10-12T07:44:28.924Z</published>
    <updated>2022-10-18T01:55:56.156Z</updated>
    
    <content type="html"><![CDATA[<p>acwing web应用课学习笔记</p><span id="more"></span><h2 id="JS的调用方式与执行顺序"><a class="header-anchor" href="#JS的调用方式与执行顺序">¶</a>JS的调用方式与执行顺序</h2><h3 id="使用方式"><a class="header-anchor" href="#使用方式">¶</a>使用方式</h3><p>HTML页面中的任意位置加上<code>&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;</code>标签即可。</p><p>常见使用方式有以下几种：</p><p>直接在<code>&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;</code>标签内写JS代码。<br>直接引入文件：<code>&lt;script type=&quot;module&quot; src=&quot;/static/js/index.js&quot;&gt;&lt;/script&gt;</code>。<br>将所需的代码通过import关键字引入到当前作用域。</p><p><code>type=&quot;module&quot;</code>能够限制变量作用域，若不加则为全局变量，其他页面也可以引用</p><p>例如：</p><p><code>/static/js/index.js</code>文件中的内容为：</p><pre><code class="language-javascript">let name = &quot;acwing&quot;;function print() &#123;    console.log(&quot;Hello World!&quot;);&#125;export &#123;    name,    print&#125;</code></pre><p><code>exprt</code>中为想要暴露在外的内容，即允许其他模块引用</p><p><code>&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;</code>中的内容为：</p><pre><code class="language-javascript">&lt;script type=&quot;module&quot;&gt;    import &#123; name, print &#125; from &quot;/static/js/index.js&quot;;    console.log(name);print();&lt;/script&gt;</code></pre><h3 id="执行顺序"><a class="header-anchor" href="#执行顺序">¶</a>执行顺序</h3><ol><li>类似于HTML与CSS，<u>按从上到下的顺序执行</u>；</li><li>事件驱动执行；</li></ol><h3 id="HTML-CSS-JavaScript三者之间的关系"><a class="header-anchor" href="#HTML-CSS-JavaScript三者之间的关系">¶</a>HTML, CSS, JavaScript三者之间的关系</h3><ol><li>CSS控制HTML</li><li>JavaScript控制HTML与CSS</li><li>为了方便开发与维护，<u>尽量按照上述顺序写代码</u>。例如：不要在HTML中调用JavaScript中的函数。</li></ol><h2 id="变量与运算符"><a class="header-anchor" href="#变量与运算符">¶</a>变量与运算符</h2><h3 id="let与const"><a class="header-anchor" href="#let与const">¶</a>let与const</h3><p>用来声明变量，作用范围为当前作用域。</p><ul><li><p>let用来定义变量（可只声明不赋值）；</p></li><li><p>const用来定义常量；</p></li></ul><p>例如：</p><pre><code class="language-javascript">let s = &quot;acwing&quot;, x = 5;let d = &#123;    name: &quot;yxc&quot;,//声明时name可以加引号也可不加    age: 18,&#125;const n = 100;</code></pre><h3 id="变量类型"><a class="header-anchor" href="#变量类型">¶</a>变量类型</h3><ul><li><code>number</code>：数值变量，例如1, 2.5</li><li><code>string</code>：字符串，例如<code>&quot;acwing&quot;</code>, <code>'yxc'</code>，单引号与双引号均可。字符串中的每个字符为只读类型。</li><li><code>boolean</code>：布尔值，例如true, false</li><li><code>object</code>：对象，类似于C++中的指针，例如[1, 2, 3]，{name: “yxc”, age: 18}，null</li><li><code>undefined</code>：未定义的变量</li></ul><p>类似于Python，JavaScript中的变量类型可以动态变化。</p><p>从字典中取出数据。第一种情况关键字可变</p><pre><code class="language-javascript">console.log(d['name'],d[&quot;age&quot;]);console.log(d.name,d.age)</code></pre><p>字典中定义用<code>：</code></p><p>外面赋值用<code>=</code></p><h3 id="运算符"><a class="header-anchor" href="#运算符">¶</a>运算符</h3><p>与C++、Python、Java类似，不同点：</p><ul><li><code>**</code>表示乘方</li><li>等于与不等于用<code>===</code>和<code>!==</code>（同时判断类型和数值，若少一个等号只能判断表面上的数值）</li></ul><h2 id="输入与输出"><a class="header-anchor" href="#输入与输出">¶</a>输入与输出</h2><h3 id="输入"><a class="header-anchor" href="#输入">¶</a>输入</h3><ul><li><p>从HTML与用户的交互中输入信息，例如通过<code>input</code>、<code>textarea</code>等标签获取用户的键盘输入，通过<code>click</code>、<code>hover</code>等事件获取用户的鼠标输入。</p></li><li><p>通过<code>Ajax</code>与<code>WebSocket</code>从服务器端获取输入</p></li><li><p>标准输入</p><pre><code class="language-javascript">let fs = require('fs');let buf = '';process.stdin.on('readable', function() &#123;    let chunk = process.stdin.read();    if (chunk) buf += chunk.toString();&#125;);process.stdin.on('end', function() &#123;    buf.split('\n').forEach(function(line) &#123;        let tokens = line.split(' ').map(function(x) &#123; return parseInt(x); &#125;);        if (tokens.length != 2) return;        console.log(tokens.reduce(function(a, b) &#123; return a + b; &#125;));    &#125;);&#125;);</code></pre><h4 id="补充"><a class="header-anchor" href="#补充">¶</a>补充</h4><pre><code class="language-javascript">letfs= require('fs') //**使用fs模块来实现所有有关文件及目录的创建、写入及删除操作。letpath = require('path'); //用于处理文件与目录的路径。</code></pre><p>process.stdin属性是流程模块的内置应用程序编程接口，用于侦听用户输入。流程对象的stdin属性是可读流。它使用on()函数来监听事件。</p><p><strong>用法:</strong></p><pre><code>process.stdin.on();</code></pre><p>**返回值：**它不返回任何值。</p><p>**参数：**此属性从用户处获取输入。</p></li></ul><h3 id="输出"><a class="header-anchor" href="#输出">¶</a>输出</h3><ul><li><p>调试用<code>console.log</code>，会将信息输出到浏览器控制台</p></li><li><p>改变当前页面的HTML与CSS</p></li><li><p>通过<code>Ajax</code>与<code>WebSocket</code>将结果返回到服务器</p><ul><li>使用 <strong>window.alert()</strong> 弹出警告框。</li><li>使用 <strong>document.write()</strong> 方法将内容写到 HTML 文档中。</li><li>使用 <strong>innerHTML</strong> 写入到 HTML 元素。</li><li>使用 <strong>console.log()</strong> 写入到浏览器的控制台。</li></ul><blockquote><p>严格来说，JavaScript 没有任何打印或者输出的函数，以上几种方式都只不过是一种数据展示的方法，最接近输出的方法应该是console，但这种方法只是一种调试辅助工具。</p></blockquote></li></ul><h3 id="格式化字符串"><a class="header-anchor" href="#格式化字符串">¶</a>格式化字符串</h3><p>字符串中填入数值：</p><pre><code class="language-javascript">let name = 'yxc', age = 18;let s = `My name is $&#123;name&#125;, I'm $&#123;age&#125; years old.`;</code></pre><p>定义多行字符串：</p><pre><code class="language-javascript">let s = `&lt;div&gt;    &lt;h2&gt;标题&lt;/h2&gt;    &lt;p&gt;段落&lt;/p&gt;/div&gt;</code></pre><p>保留两位小数如何输出</p><pre><code class="language-js">let x = 1.234567;let s = `$&#123;x.toFixed(2)&#125;`;</code></pre><h2 id="判断语句"><a class="header-anchor" href="#判断语句">¶</a>判断语句</h2><p>JavaScript中的<code>if-else</code>语句与C++、Python、Java中类似。</p><p>例如：</p><pre><code class="language-javascript">let score = 90;if (score &gt;= 85) &#123;    console.log(&quot;A&quot;);&#125; else if (score &gt;= 70) &#123;    console.log(&quot;B&quot;);&#125; else if (score &gt;= 60) &#123;    console.log(&quot;C&quot;);&#125; else &#123;    console.log(&quot;D&quot;);&#125;</code></pre><p>JavaScript中的逻辑运算符也与C++、Java中类似：</p><ul><li>&amp;&amp;表示与</li><li>||表示或</li><li>!表示非</li></ul><h2 id="循环语句"><a class="header-anchor" href="#循环语句">¶</a>循环语句</h2><p>JavaScript中的循环语句与C++中类似，也包含for、while、do while循环。</p><h3 id="for循环"><a class="header-anchor" href="#for循环">¶</a>for循环</h3><pre><code class="language-javascript">for (let i = 0; i &lt; 10; i++) &#123;    console.log(i);&#125;</code></pre><p>枚举对象或数组时可以使用：</p><ul><li><code>for-in</code>循环，可以枚举数组中的下标，以及对象中的<code>key</code></li><li><code>for-of</code>循环，可以枚举数组中的值，以及对象中的<code>value</code></li></ul><h3 id="while循环"><a class="header-anchor" href="#while循环">¶</a>while循环</h3><pre><code class="language-javascript">let i = 0;while (i &lt; 10) &#123;    console.log(i);    i++;&#125;</code></pre><h3 id="do-while循环"><a class="header-anchor" href="#do-while循环">¶</a>do while循环</h3><p><code>do while</code>语句与<code>while</code>语句非常相似。唯一的区别是，<code>do while</code>语句限制性循环体后检查条件。不管条件的值如何，我们都要至少执行一次循环。</p><pre><code class="language-javascript">let i = 0;do &#123;    console.log(i);    i++;&#125; while (i &lt; 10);</code></pre><h2 id="对象"><a class="header-anchor" href="#对象">¶</a>对象</h2><p>英文名称：<code>Object</code>。<br>类似于C++中的map，由key:value对构成。</p><ul><li>value可以是变量、数组、对象、函数等。</li><li>函数定义中的this用来引用该函数的“拥有者”。</li></ul><p>例如：</p><pre><code class="language-javascript">let person = &#123;    name: &quot;yxc&quot;,    age: 18,    money: 0,    add_money: function (x) &#123;        this.money += x;    &#125;&#125;</code></pre><p>对象属性与函数的调用方式：</p><ul><li><code>person.name</code>、<code>person.add_money()</code></li><li><code>person[&quot;name&quot;]</code>、<code>[person[&quot;add_money&quot;]()</code></li></ul><h2 id="数组"><a class="header-anchor" href="#数组">¶</a>数组</h2><p>数组是一种特殊的对象。<br>类似于C++中的数组，但是数组中的元素类型可以不同。</p><ul><li><p>数组中的元素可以是变量、数组、对象、函数。</p><p>例如：</p></li></ul><pre><code class="language-javascript">let a = [1, 2, &quot;a&quot;, &quot;yxc&quot;];let b = [    1,  // 变量    &quot;yxc&quot;,  // 变量    ['a', 'b', 3],  // 数组    function () &#123;  // 函数        console.log(&quot;Hello World&quot;);    &#125;,    &#123; name: &quot;yxc&quot;, age: 18 &#125;  // 对象];</code></pre><h3 id="访问数组中的元素"><a class="header-anchor" href="#访问数组中的元素">¶</a>访问数组中的元素</h3><p>通过下标。</p><p>例如：</p><pre><code class="language-javascript">a[0] = 1; // 访问数组a[]的第0个元素console.log(a[0]);</code></pre><h3 id="数组的常用属性和函数"><a class="header-anchor" href="#数组的常用属性和函数">¶</a>数组的常用属性和函数</h3><ul><li>属性<code>length</code>：返回数组长度。注意<code>length</code>是属性，不是函数，因此调用的时候不要加()</li><li>函数<code>push()</code>：向数组末尾添加元素</li><li>函数<code>pop()</code>：删除数组末尾的元素</li><li>函数<code>splice(a, b)</code>：删除从a开始的b个元素</li><li>函数<code>sort()</code>：将整个数组从小到大排序</li></ul><p>​自定义比较函数：<code>array.sort(cmp)</code>，函数cmp输入两个需要比较的元素，返回一个实数，负数表示第一个参数小于第二个参数，0表示相等，正数表示大于。</p><h3 id="函数"><a class="header-anchor" href="#函数">¶</a>函数</h3><p>函数是用对象来实现的。<br>函数也C++中的函数类似。</p><h3 id="定义方式"><a class="header-anchor" href="#定义方式">¶</a>定义方式</h3><pre><code class="language-javascript">function add(a, b) &#123;    return a + b;&#125;let add = function (a, b) &#123;    return a + b;&#125;let add = (a, b) =&gt; &#123;    return a + b;&#125;</code></pre><h3 id="返回值"><a class="header-anchor" href="#返回值">¶</a>返回值</h3><p>如果未定义返回值，则返回<code>undefined</code>。</p><h2 id="类"><a class="header-anchor" href="#类">¶</a>类</h2><p>与C++中的Class类似。但是不存在私有成员。</p><ul><li><p><code>this</code>指向类的实例。</p><h3 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h3><pre><code class="language-javascript">class Point &#123;      constructor(x, y) &#123;  // 构造函数          this.x = x;  // 成员变量          this.y = y;        this.init();    &#125;        init() &#123;        this.sum = this.x + this.y;  // 成员变量可以在任意的成员函数中定义    &#125;        toString() &#123;  // 成员函数        return '(' + this.x + ', ' + this.y + ')';    &#125;&#125;let p = new Point(3, 4);//用new关键字创建console.log(p.toString());</code></pre><h3 id="继承"><a class="header-anchor" href="#继承">¶</a>继承</h3><pre><code class="language-javascript"> class ColorPoint extends Point &#123;      constructor(x, y, color) &#123;          super(x, y); // 这里的super表示父类的构造函数          this.color = color;      &#125;    toString() &#123;        return this.color + ' ' + super.toString(); // 调用父类的toString()    &#125;&#125;</code></pre></li></ul><h3 id="注意："><a class="header-anchor" href="#注意：">¶</a>注意：</h3><ul><li><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。</p><p>​作为函数调用时，代表父类的构造函数，且只能用在子类的构造函数之中。</p></li></ul><p>​<code>super</code>作为对象时，指向父类的原型对象。</p><p>​   在每次继承父函数后，必须要先使用super调用一下，并且this这个属性必须在super之后调用</p><ul><li><p>在子类的构造函数中，<u>只有调用<code>super</code>之后，才可以使用<code>this</code>关键字</u>。</p></li><li><p>成员重名时，子类的成员会覆盖父类的成员。类似于C++中的多态。</p></li><li><p>在子类的构造函数中，<u>只有调用super之后，才可以使用this关键字</u>。</p></li><li><p>成员重名时，子类的成员会覆盖父类的成员。类似于JAVA中的多态。</p></li><li><p>js的调用具有一定的惰性，只有调用的时候，有错误的函数才会报错</p></li><li><p>用在构造器里面的super指代父类的构造函数，用在其他成员里的super指代子类的对象</p></li></ul><h3 id="静态方法"><a class="header-anchor" href="#静态方法">¶</a>静态方法</h3><p>在成员函数前添加<code>static</code>关键字即可。静态方法不会被类的实例继承，只能通过类来调用，但是静态成员函数是可以被继承的，静态成员变量可以被子类调用。例如：</p><pre><code class="language-javascript">class Point &#123;    constructor(x, y) &#123;        this.x = x;        this.y = y;    &#125;    toString() &#123;        return '(' + this.x + ', ' + this.y + ')';    &#125;        static print_class_name() &#123;        console.log(&quot;Point&quot;);    &#125;&#125;let p = new Point(1, 2);Point.print_class_name();p.print_class_name();  // 会报错</code></pre><h3 id="静态变量"><a class="header-anchor" href="#静态变量">¶</a>静态变量</h3><p>在ES6中，只能通过<code>class.propname</code>定义和访问。例如：</p><pre><code class="language-javascript">class Point &#123;    constructor(x, y) &#123;        this.x = x;        this.y = y;        Point.cnt++;    &#125;        toString() &#123;        return '(' + this.x + ', ' + this.y + ')';    &#125;&#125;Point.cnt = 0;let p = new Point(1, 2);let q = new Point(3, 4);console.log(Point.cnt);</code></pre><h2 id="事件"><a class="header-anchor" href="#事件">¶</a>事件</h2><p>JavaScript的代码一般通过事件触发。</p><p>可以通过<code>addEventListener</code>函数为元素绑定事件的触发函数。</p><p>常见的触发函数有：</p><h3 id="鼠标"><a class="header-anchor" href="#鼠标">¶</a>鼠标</h3><ul><li><code>click</code>：鼠标左键点击</li><li><code>dblclick</code>：鼠标左键双击</li><li><code>contextmenu</code>：鼠标右键点击（理解为触发右键）</li><li><code>mousedown</code>：鼠标按下，包括左键、滚轮、右键</li></ul><p>​<code>event.button</code>：0表示左键，1表示中键，2表示右键</p><ul><li><p><code>mouseup</code>：鼠标弹起，包括左键、滚轮、右键</p></li><li><p>mouseup：鼠标弹起，包括左键、滚轮、右键</p></li></ul><p>​<code>event.button</code>：0表示左键，1表示中键，2表示右键</p><pre><code class="language-javascript">//可以对定义的div添加事件，首先需要获取let div = document.querySelector('div');let manner = function () &#123;    // 前面的是触发事件的类型，后面的添加对应的函数    div.addEventListener(&quot;contextmenu&quot;,function(event)&#123;        console.log(event.type)    &#125;);&#125;//将函数暴露出去的函数export &#123;    manner,&#125;</code></pre><p>使元素获得感触到事件的前提是能够聚焦，比如<code>div</code>可以使用<code>tabindex</code>属性</p><h3 id="键盘"><a class="header-anchor" href="#键盘">¶</a>键盘</h3><ul><li><p><code>keydown</code>：某个键是否被按住，事件会连续触发</p><p>​<code>event.code</code>：返回按的是哪个键</p><p>​<code>event.altKey</code>、<code>event.ctrlKey</code>、<code>event.shiftKey</code>分别表示是否同时按下了<code>alt</code>、<code>ctrl</code>、<code>shift</code>键。</p></li><li><p><code>keyup</code>：某个按键是否被释放</p><p>​<code>event</code>常用属性同上</p></li><li><p><code>keypress</code>：紧跟在<code>keydown</code>事件后触发，只有按下字符键时触发。适用于判定用户输入的字符。</p><p>​<code>event</code>常用属性同上</p><p><code>keydown</code>、<code>keyup</code>、<code>keypress</code>的关系类似于鼠标的<code>mousedown</code>、<code>mouseup</code>、<code>click</code></p></li></ul><h3 id="表单"><a class="header-anchor" href="#表单">¶</a>表单</h3><ul><li><code>focus</code>：聚焦某个元素</li><li><code>blur</code>：取消聚焦某个元素</li><li><code>change</code>：某个元素的内容发生了改变</li></ul><h3 id="窗口"><a class="header-anchor" href="#窗口">¶</a>窗口</h3><p>需要作用到<code>window</code>元素上。</p><p>`resize：当窗口大小放生变化</p><p><code>scroll</code>：滚动指定的元素</p><p><code>load</code>：当元素被加载完成</p><h2 id="常用库"><a class="header-anchor" href="#常用库">¶</a>常用库</h2><h3 id="jQuery"><a class="header-anchor" href="#jQuery">¶</a>jQuery</h3><h4 id="使用方式-v2"><a class="header-anchor" href="#使用方式-v2">¶</a>使用方式</h4><ul><li>在<code>&lt;head&gt;</code>元素中添加：</li></ul><pre><code class="language-javascript">&lt;script src=&quot;https://cdn.acwing.com/static/jquery/js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;</code></pre><ul><li><p>按jQuery官网提示下载</p><h4 id="选择器"><a class="header-anchor" href="#选择器">¶</a>选择器</h4><p><code>$(selector)</code>，例如：</p></li></ul><pre><code class="language-javascript">$('div');$('.big-div');$('div &gt; p')</code></pre><p>selector类似于CSS选择器。</p><h4 id="事件-v2"><a class="header-anchor" href="#事件-v2">¶</a>事件</h4><p><code>$(selector).on(event, func)</code>绑定事件，例如：</p><pre><code class="language-javascript">$('div').on('click', function (e) &#123;    console.log(&quot;click div&quot;);&#125;)</code></pre><p><code>$(selector).off(event, func</code>)删除事件，例如：</p><pre><code class="language-js">$('div').on('click', function (e) &#123;    console.log(&quot;click div&quot;);$('div').off('click');&#125;);</code></pre><p>当存在多个相同类型的事件触发函数时，可以通过<code>click.name</code>来区分，例如：</p><pre><code class="language-javascript">$('div').on('click.first', function (e) &#123;    console.log(&quot;click div&quot;);$('div').off('click.first');&#125;);</code></pre><p>在事件触发的函数中的<code>return false</code>等价于同时执行：</p><ul><li><code>e.stopPropagation()</code>：阻止事件向上传递，父标签的事件不再触发</li><li><code>e.preventDefault()</code>：阻止事件的默认行为</li></ul><p>也可以不使用<code>on</code>，使用<code>click</code>，但是<code>click</code>不能改名字</p><h4 id="元素的隐藏、展现"><a class="header-anchor" href="#元素的隐藏、展现">¶</a>元素的隐藏、展现</h4><p>单位都是毫秒</p><ul><li><code>$A.hide()</code>：隐藏，可以添加参数，表示消失时间</li><li><code>$A.show()</code>：展现，可以添加参数，表示出现时间</li><li><code>$A.fadeOut()</code>：慢慢消失，可以添加参数，表示消失时间</li><li><code>$A.fadeIn()</code>：慢慢出现，可以添加参数，表示出现时间</li></ul><h4 id="元素的添加、删除"><a class="header-anchor" href="#元素的添加、删除">¶</a>元素的添加、删除</h4><ul><li><code>$('&lt;div class=&quot;mydiv&quot;&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;/div&gt;')</code>：构造一个jQuery对象</li><li><code>$A.append($B)</code>：将$B添加到$A的末尾</li><li><code>$A.prepend($B)</code>：将$B添加到$A的开头</li><li><code>$A.remove()</code>：删除元素$A</li><li><code>$A.empty()</code>：清空元素$A的所有儿子</li></ul><h4 id="对类的操作"><a class="header-anchor" href="#对类的操作">¶</a>对类的操作</h4><ul><li><code>$A.addClass(class_name)</code>：添加某个类</li><li><code>$A.removeClass(class_name)</code>：删除某个类</li><li><code>$A.hasClass(class_name)</code>：判断某个类是否存在</li></ul><h4 id="对CSS的操作"><a class="header-anchor" href="#对CSS的操作">¶</a>对CSS的操作</h4><ul><li><p><code>$(&quot;div&quot;).css(&quot;background-color&quot;)</code>：获取某个CSS的属性</p></li><li><p><code>$(&quot;div&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;)</code>：设置某个CSS的属性</p><p>同时设置多个CSS的属性（传入一个对象进去）：</p></li></ul><pre><code class="language-javascript">$('div').css(&#123;    width: &quot;200px&quot;,    height: &quot;200px&quot;,    &quot;background-color&quot;: &quot;orange&quot;,//若属性中包含‘-’，可能出现歧义，故需要把属性名括起来&#125;);</code></pre><h4 id="对标签属性的操作"><a class="header-anchor" href="#对标签属性的操作">¶</a>对标签属性的操作</h4><p>也可是自定义属性的值</p><p><code>$('div').attr('id')</code>：获取属性<br><code>$('div').attr('id', 'ID')</code>：设置属性</p><h4 id="对HTML内容、文本的操作"><a class="header-anchor" href="#对HTML内容、文本的操作">¶</a>对HTML内容、文本的操作</h4><p>不需要背每个标签该用哪种，用到的时候Google或者百度即可。</p><p><u>不加参数是获取，加上参数是修改</u></p><p><code>$A.html()</code>：获取、修改HTML内容<br><code>$A.text()</code>：获取、修改文本信息<br><code>$A.val()</code>：获取、修改文本的值</p><h4 id="查找"><a class="header-anchor" href="#查找">¶</a>查找</h4><ul><li><code>$(selector).parent(filter)</code>：查找父元素</li><li><code>$(selector).parents(filter)</code>：查找所有祖先元素</li><li><code>$(selector).children(filter)</code>：在所有子元素中查找</li><li><code>$(selector).find(filter)</code>：在所有后代元素中查找</li></ul><h4 id="ajax"><a class="header-anchor" href="#ajax">¶</a>ajax</h4><h5 id="GET方法："><a class="header-anchor" href="#GET方法：">¶</a>GET方法：</h5><pre><code class="language-javascript">$.ajax(&#123;    url: url,    type: &quot;GET&quot;,    data: &#123;    &#125;,    dataType: &quot;json&quot;,    success: function (resp) &#123;&#125;,&#125;);</code></pre><h5 id="POST方法："><a class="header-anchor" href="#POST方法：">¶</a>POST方法：</h5><pre><code class="language-javascript">$.ajax(&#123;    url: url,    type: &quot;POST&quot;,    data: &#123;    &#125;,    dataType: &quot;json&quot;,    success: function (resp) &#123;&#125;,&#125;);</code></pre><h3 id="setTimeout与setInterval"><a class="header-anchor" href="#setTimeout与setInterval">¶</a>setTimeout与setInterval</h3><p><code>setTimeout(func, delay)</code><br><code>delay</code>毫秒后，执行函数<code>func()</code>。</p><h4 id="clearTimeout"><a class="header-anchor" href="#clearTimeout">¶</a>clearTimeout()</h4><p>关闭定时器，例如：</p><p>定时器函数返回值是一个唯一的id，可以通过id对其进行关闭</p><pre><code class="language-javascript">let timeout_id = setTimeout(() =&gt; &#123;    console.log(&quot;Hello World!&quot;)&#125;, 2000);  // 2秒后在控制台输出&quot;Hello World&quot;clearTimeout(timeout_id);  // 清除定时器</code></pre><h4 id="setInterval-func-delay"><a class="header-anchor" href="#setInterval-func-delay">¶</a>setInterval(func, delay)</h4><p>每隔<code>delay</code>毫秒，执行一次函数<code>func()</code>。<br>第一次在第<code>delay</code>毫秒后执行。</p><h4 id="clearInterval"><a class="header-anchor" href="#clearInterval">¶</a>clearInterval()</h4><p>关闭周期执行的函数，例如：</p><pre><code class="language-javascript">let interval_id = setInterval(() =&gt; &#123;    console.log(&quot;Hello World!&quot;)&#125;, 2000);  // 每隔2秒，输出一次&quot;Hello World&quot;clearInterval(interval_id);  // 清除周期执行的函数</code></pre><h3 id="requestAnimationFrame"><a class="header-anchor" href="#requestAnimationFrame">¶</a>requestAnimationFrame</h3><p><code>requestAnimationFrame(func)</code><br>该函数会在下次浏览器刷新页面之前执行一次，通常会用递归写法使其每秒执行60次<code>func</code>函数。调用时会传入一个参数，表示函数执行的时间戳，单位为毫秒。</p><p>例如：</p><pre><code class="language-js">let step = (timestamp) =&gt; &#123;  // 每帧将div的宽度增加1像素    let div = document.querySelector('div');    div.style.width = div.clientWidth + 1 + 'px';    requestAnimationFrame(step);&#125;;requestAnimationFrame(step);</code></pre><p>与<code>setTimeout</code>和<code>setInterval</code>的区别：</p><p><code>requestAnimationFrame</code>渲染动画的效果更好，性能更加。</p><p>该函数可以保证每两次调用之间的时间间隔相同，但<code>setTimeout</code>与<code>setInterval</code>不能保证这点。<code>setTmeout</code>两次调用之间的间隔包含回调函数的执行时间；<code>setInterval</code>只能保证按固定时间间隔将回调函数压入栈中，前端js是单线程执行，但具体的执行时间间隔仍然受回调函数的执行时间影响。</p><p>当页面在后台时，因为页面不再渲染，因此<code>requestAnimationFrame</code>不再执行。但<code>setTimeout</code>与<code>setInterva</code>函数会继续执行。</p><p><img src="/images/requestAnimationFrame.png" alt="image-20221014140838312">如果想要获取或者继续调用每一帧执行的<code>requestAnimationFrame</code>函数，必须保证<code>func_id</code>是被实时更新得到的，否则每次帧率更新都会返回一个新的函数id</p><h3 id="Map与Set"><a class="header-anchor" href="#Map与Set">¶</a>Map与Set</h3><h4 id="Map"><a class="header-anchor" href="#Map">¶</a>Map</h4><p>Map 对象保存键值对。</p><ul><li>用<code>for...of</code>或者<code>forEach</code>可以按插入顺序遍历。</li></ul><p><img src="/images/js_map.png" alt="image-20221014142135640"></p><ul><li>键值可以为任意值，包括函数、对象或任意基本类型。</li></ul><p>常用API：</p><ul><li><code>set(key, value)</code>：插入键值对，如果<code>key</code>已存在，则会覆盖原有的value</li><li><code>get(key)</code>：查找关键字，如果不存在，返回<code>undefined</code></li><li><code>size</code>：返回键值对数量</li><li><code>has(key)</code>：返回是否包含关键字<code>key</code></li><li><code>delete(key)</code>：删除关键字<code>key</code></li><li><code>clear()</code>：删除所有元素</li></ul><h4 id="Set"><a class="header-anchor" href="#Set">¶</a>Set</h4><p><code>Set</code> 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p><ul><li><p>用<code>for...of</code>或者<code>forEach</code>可以按插入顺序遍历。</p><p>常用API：</p></li><li><p><code>add()</code>：添加元素</p></li><li><p><code>has()</code>：返回是否包含某个元素</p></li><li><p><code>size</code>：返回元素数量</p></li><li><p><code>delete()</code>：删除某个元素</p></li><li><p><code>clear()</code>：删除所有元素</p></li></ul><h3 id="localStorage"><a class="header-anchor" href="#localStorage">¶</a>localStorage</h3><p>可以在用户的浏览器上存储键值对。</p><p>常用API：</p><ul><li><p><code>setItem(key, value)</code>：插入</p></li><li><p><code>getItem(key)</code>：查找</p></li><li><p><code>removeItem(key)</code>：删除</p></li><li><p><code>clear()</code>：清空</p><h3 id="JSON"><a class="header-anchor" href="#JSON">¶</a>JSON</h3></li></ul><p>JSON对象用于序列化对象、数组、数值、字符串、布尔值和null。</p><p>常用API：</p><ul><li><code>JSON.parse()</code>：将字符串解析成对象</li><li><code>JSON.stringify()</code>：将对象转化为字符串</li></ul><h3 id="日期"><a class="header-anchor" href="#日期">¶</a>日期</h3><p>返回值为整数的API，数值为<code>1970-1-1 00:00:00 UTC</code>（世界标准时间）到某个时刻所经过的毫秒数：</p><ul><li><code>Date.now()</code>：返回现在时刻。</li><li><code>Date.parse(&quot;2022-04-15T15:30:00.000+08:00&quot;)</code>：返回北京时间2022年4月15日 15:30:00的时刻。</li></ul><h4 id="与Date对象的实例相关的API："><a class="header-anchor" href="#与Date对象的实例相关的API：">¶</a>与Date对象的实例相关的API：</h4><ul><li><p><code>new Date()</code>：返回现在时刻。</p></li><li><p><code>new Date(&quot;2022-04-15T15:30:00.000+08:00&quot;)</code>：返回北京时间2022年4月15日 15:30:00的时刻。</p></li><li><p>两个<code>Date</code>对象实例的差值为毫秒数</p></li><li><p><code>getDay()</code>：返回星期，0表示星期日，1-6表示星期一至星期六</p></li><li><p><code>getDate()</code>：返回日，数值为1-31</p></li><li><p><code>getMonth()</code>：返回月，数值为0-11</p></li><li><p><code>getFullYear()</code>：返回年份</p></li><li><p><code>getHours()</code>：返回小时</p></li><li><p><code>getMinutes()</code>：返回分钟</p></li><li><p><code>getSeconds()</code>：返回秒</p></li><li><p><code>getMilliseconds()</code>：返回毫秒</p><h3 id="WebSocket"><a class="header-anchor" href="#WebSocket">¶</a>WebSocket</h3></li></ul><p>与服务器建立全双工连接。</p><p>常用API：</p><ul><li><code>new WebSocket('ws://localhost:8080')</code>;：建立ws连接。</li><li><code>send()</code>：向服务器端发送一个字符串。一般用JSON将传入的对象序列化为字符串。</li><li><code>onopen</code>：类似于<code>onclick</code>，当连接建立时触发。</li><li><code>onmessage</code>：当从服务器端接收到消息时触发。</li><li><code>close()</code>：关闭连接。</li><li><code>onclose</code>：当连接关闭后触发。</li></ul><h3 id="window"><a class="header-anchor" href="#window">¶</a>window</h3><ul><li><code>window.open(&quot;https://www.acwing.com&quot;)</code>在新标签栏中打开页面。</li><li><code>location.reload()</code>刷新页面。</li><li><code>location.href = &quot;https://www.acwing.com&quot;</code>：在当前标签栏中打开页面。</li></ul><h3 id="canvas"><a class="header-anchor" href="#canvas">¶</a>canvas</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial">Canvas 教程 - Web API 接口参考 | MDN (mozilla.org)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;acwing web应用课学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="语言学习" scheme="http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="others" scheme="http://example.com/tags/others/"/>
    
    <category term="JAVASCRIPT" scheme="http://example.com/tags/JAVASCRIPT/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记（3）-函数（2）</title>
    <link href="http://example.com/2022/10/02/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89-%E5%87%BD%E6%95%B0%EF%BC%882%EF%BC%89/"/>
    <id>http://example.com/2022/10/02/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89-%E5%87%BD%E6%95%B0%EF%BC%882%EF%BC%89/</id>
    <published>2022-10-02T07:17:26.225Z</published>
    <updated>2022-10-22T11:05:30.387Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学py，简单记录一下笔记</p><span id="more"></span><h3 id="闭包"><a class="header-anchor" href="#闭包">¶</a>闭包</h3><p>函数名是一个变量, 但它是一个特殊的变量, 与括号配合可以执行函数的变量.</p><h4 id=""><a class="header-anchor" href="#">¶</a></h4><p>内层函数使用外层函数的局部变量</p><ul><li>让一个变量被封锁起来，外界只能看到但是无法修改</li><li>可以让一个变量常驻内存</li></ul><h4 id="函数名的内存地址"><a class="header-anchor" href="#函数名的内存地址">¶</a>函数名的内存地址</h4><pre><code class="language-python">def func():    print(&quot;呵呵&quot;)print(func)结果:&lt;function func at 0x1101e4ea0&gt;</code></pre><h4 id="函数名可以赋值给其他变量"><a class="header-anchor" href="#函数名可以赋值给其他变量">¶</a>函数名可以赋值给其他变量</h4><pre><code class="language-python">def func():    print(&quot;呵呵&quot;)print(func)a = func    # 把函数当成一个变量赋值给另一个变量a()     # 函数调用 func()</code></pre><h4 id="函数名可以当做容器类的元素"><a class="header-anchor" href="#函数名可以当做容器类的元素">¶</a>函数名可以当做容器类的元素</h4><pre><code class="language-python">def func1():    print(&quot;呵呵&quot;)def func2():    print(&quot;呵呵&quot;)def func3():    print(&quot;呵呵&quot;)lst = [func1, func2, func3]for i in lst:    i()</code></pre><h4 id="函数名可以当做函数的参数"><a class="header-anchor" href="#函数名可以当做函数的参数">¶</a>函数名可以当做函数的参数</h4><pre><code class="language-python">def func():    print(&quot;吃了么&quot;)def func2(fn):    print(&quot;我是func2&quot;)    fn()    # 执行传递过来的fn    print(&quot;我是func2&quot;)func2(func)     # 把函数func当成参数传递给func2的参数fn.</code></pre><h4 id="函数名可以作为函数的返回值"><a class="header-anchor" href="#函数名可以作为函数的返回值">¶</a>函数名可以作为函数的返回值</h4><pre><code class="language-python">def func_1():    print(&quot;这里是函数1&quot;)    def func_2():        print(&quot;这里是函数2&quot;)    print(&quot;这里是函数1&quot;)    return func_2fn = func_1()   # 执行函数1.  函数1返回的是函数2, 这时fn指向的就是上面函数2fn()    # 执行上面返回的函数</code></pre><p>闭包. 其实很简单. 就是内层函数使用了外层函数中的变量, 就是闭包</p><pre><code class="language-python">def outer():    a = 10    def inner():        print(a)  # 这个就是闭包    return inner  # 闭包通常都是返回内层函数</code></pre><p>闭包有什么用呢. 注意看了. 当我们外部访问了这个outer()函数. 得到的结果就是inner函数</p><pre><code class="language-python">a = outer()</code></pre><p>此时. 我们拿到了一个变量a. 而这个变量a是outer()的返回值. 也就是inner函数. 所以. 我们可以</p><pre><code class="language-python">a()  # 此时执行的是inner这个函数    </code></pre><p>由于函数inner的执行时间是在outer()外部. 这就决定了inner执行的时间我们是不确定的，而变量a是一个局部变量. 正常情况下执行玩儿outer(), 它就没有意义了。但是, 此时由于inner函数执行时间的不确定， 又必须保证inner能正常执行，python就规定， 闭包函数中使用的变量会常驻于内存，而且， 在outer()外部， 是无法改变这个值的. 故称: 闭包。 <u>目的有两个: 其一是不许外面改变这个变量. 其二是让这个变量常驻于内存。</u></p><p>闭包的应用: 装饰器</p><p>​</p><h3 id="装饰器"><a class="header-anchor" href="#装饰器">¶</a>装饰器</h3><p>装饰器是干嘛的呢?  它是一种固定的语法. 可以让我们在不修改原有函数内部代码的基础上, 给函数增加新的功能.</p><pre><code class="language-python">def add():    passdef delete():    passdef update():    passdef search():    pass</code></pre><p>此时, 我想给每个函数添加一个新功能. 记录日志. 记录一下. 在xxx时间执行的xxx函数.</p><pre><code class="language-python">def add():    # 记录日志的代码    passdef delete():    # 记录日志的代码    passdef update():    # 记录日志的代码    passdef search():    # 记录日志的代码    pass</code></pre><p>设想一下, 如果我现在想更换日志格式: xxx函数在xxx时间执行了. 你怎么办.</p><p>传统办法:  改代码. 修改每个函数. --&gt; 太蠢了. 如果这一段代码有1000次重复. 你要修改1000次.</p><p>高级办法:  把记录日志的代码提取成函数. 然后每个函数分别调用.</p><pre><code class="language-python">def log():    # 记录日志的代码    pass    def add():    log()    passdef delete():    log()    passdef update():    log()    passdef search():    log()    pass</code></pre><p>这样的话只要修改log()函数就可以完成我们想要的结果了. 但是, 随着需求的进一步增加. 你会发现你这几个函数没有消停的时候了.  例如, 不论执行增删改查任何操作之前都要进行登录验证.</p><pre><code class="language-python">def add():    while 1:        uname = input(&quot;&gt;&gt;&gt;&quot;)        pwd = input(&quot;&gt;&gt;&gt;&quot;)        if uname == 'jolin' and pwd == &quot;123&quot;:            log()            pass                        break        else:            print(&quot;密码错误&quot;)            def delete():    log()    passdef update():    log()    passdef search():    log()    pass</code></pre><p>发现没有, 如果继续下去. 你会发现你这个add方法永无宁日. 不停的再改. 而新增的代码可能早就被复杂的而又不属于新增的业务逻辑所污染.</p><p>那怎么办呢?  在程序设计上我们的程序要遵循开闭原则</p><p>开: 对添加新功能开放</p><p>闭: 对修改函数中的源代码封闭.</p><p>普通话: 在不修改源代码内部的基础上给函数添加新功能. 这正好契合我们的装饰器.</p><h4 id="装饰器雏形"><a class="header-anchor" href="#装饰器雏形">¶</a>装饰器雏形</h4><pre><code class="language-python">def wrapper(fn):    def inner():        &quot;&quot;&quot; 在执行fn之前 &quot;&quot;&quot;        fn()  # 这里是一个闭包的效果. 外面函数中有一个fn: 局部变量被内层函数使用.         &quot;&quot;&quot; 在执行fn之后 &quot;&quot;&quot;    return inner    def add():    passdef delete():    passdef update():    passdef search():    pass </code></pre><p>上面的wrapper就是一个装饰器. 其实看起来没什么特别的, 就是一个闭包而已. 那这东西怎么用呢?</p><pre><code class="language-python">add = wrapper(add) add()</code></pre><p>其他的都不看. 就看第一行代码. add = wrapper(add) 把add函数作为参数传递给wrapper. 那么wrapper()中的fn就是外面的add函数. 然后wrapper返回inner. 此时注意了. add这个变量被修改. 重新指向inner这个函数.</p><p>那么. 注意了. 此时我们用add()执行的时候. 实际上执行的是inner()这个函数. 而inner中执行的是fn(). fn是原来的add()  饶了一大圈. 执行的还是原来的add() .</p><p>最开始, 在访问wrapper()的一瞬间是这样的:</p><p>![image-20221002100002130](/images/装饰器1 (1).png)</p><p>然后. 内存中产生inner() 并返回inner</p><p>![image-20221002095934944](/images/装饰器1 (2).png)</p><p>再然后. wrapper返回的inner重新赋值给add</p><p>![image-20221002100016066](/images/装饰器1 (3).png)</p><pre><code class="language-python">def wrapper(fn):    def inner():        &quot;&quot;&quot; 在执行fn之前 &quot;&quot;&quot;        while 1:        uname = input(&quot;&gt;&gt;&gt;&quot;)        pwd = input(&quot;&gt;&gt;&gt;&quot;)        if uname == 'jolin' and pwd == &quot;123&quot;:             log()             fn()            break        else:            print(&quot;密码错误&quot;)        &quot;&quot;&quot; 在执行fn之后 &quot;&quot;&quot;    return inner    def add():    passdef delete():    passdef update():    passdef search():    pass add = wrapper(add)add()</code></pre><p><code>add = wrapper(add)</code>看着是真的难受. 不光你们看着不爽. python的作者也不爽. 怎么办呢. python提供了一种语法糖. 可以帮助我们简化这句话</p><pre><code>@wrapper   # 相当于add = wrapper(add)def add():    pass</code></pre><p>@后面加上装饰器的名字(装饰器函数名) 就是语法糖. 相当于写了一个<code>add = warpper(add) </code></p><h4 id="通用装饰器写法"><a class="header-anchor" href="#通用装饰器写法">¶</a>通用装饰器写法</h4><pre><code class="language-python"> def wrapper(fn):    def inner(*args, **kwargs):        &quot;&quot;&quot; 在执行fn之前 &quot;&quot;&quot;        ret = fn(*args, **kwargs)        &quot;&quot;&quot; 在执行fn之后 &quot;&quot;&quot;        return ret  # 把fn执行之后的结果返回    return inner</code></pre><h4 id="同一个函数被多个装饰器装饰"><a class="header-anchor" href="#同一个函数被多个装饰器装饰">¶</a>同一个函数被多个装饰器装饰</h4><pre><code class="language-python">def wrapper1(fn):    def inner(*args, **kwargs):        print(&quot;before wrapper1&quot;)        ret = fn(*args, **kwargs)        print(&quot;after wrapper1&quot;)        return ret    return innerdef wrapper2(fn):    def inner(*args, **kwargs):        print(&quot;before wrapper2&quot;)        ret = fn(*args, **kwargs)        print(&quot;after wrapper2&quot;)        return ret    return innerdef wrapper3(fn):    def inner(*args, **kwargs):        print(&quot;before wrapper3&quot;)        ret = fn(*args, **kwargs)        print(&quot;after wrapper3&quot;)        return ret    return inner@wrapper1@wrapper2@wrapper3def func():    print(&quot;target function&quot;)func()# 结果before wrapper1before wrapper2before wrapper3target functionafter wrapper3after wrapper2after wrapper1</code></pre><p>看结果应该就能明白.  wrapper1装饰的是warpper2装饰的结果.wrapper2装饰的是wrapper3装饰的结果… 以此类推. 最接近目标函数的是wrapper3.  所以目标函数之前和之后执行的是wrapper3. 然后外面套上一层wrapper2. 最后wrapper1</p><h4 id="带参数的装饰器"><a class="header-anchor" href="#带参数的装饰器">¶</a>带参数的装饰器</h4><p>有时候我们可能需要通过参数来控制装饰器装饰的效果. 比如, 我现在想玩游戏开挂. 但是呢.  好多外挂在我面前, 我想自由切换怎么办?  难道要写很多个装饰器么. NO, 我们可以通过参数来控制装饰器内部的执行流程</p><pre><code class="language-python">def gua(fn):    def inner(*args, **kwargs):        ret = fn(*args, **kwargs)        return ret    return inner    @guadef play():    passplay()  </code></pre><p>此时我们只是开挂了. 开什么挂还不知道. 这里就可以选择使用带参数的装饰器了</p><pre><code class="language-python">def gua_bi(kind_of_gua):    def gua(fn):        def inner(*args, **kwargs):            print(&quot;我要使用%s&quot; % kind_of_gua)            ret = fn(*args, **kwargs)            return ret        return inner    return gua  # 注意这句话. 返回的是一个装饰器    @gua_bi(&quot;耄耋&quot;) #先执行函数的调用 函数返回的是一个装饰器 和@组合成语法糖 @guadef play_1():    pass@gua_bi(&quot;饕餮&quot;)def play_2():    passplay_1()    </code></pre><p>此时注意了. <code>@gua_bi(&quot;饕餮&quot;)</code>  这句话要拆开来看. 先执行的是后半段.  <code>gua_bi(&quot;饕餮&quot;)</code>  这就是一个普通函数的调用. 执行完这个函数. 返回的是<code>gua</code>. 再和前面的@组合. 正好是<code>@gua</code>. 还是原来装饰器的样子</p><h3 id="迭代器"><a class="header-anchor" href="#迭代器">¶</a>迭代器</h3><p>迭代器最大的作用个就是统一了容器类型循环遍历的标准</p><p>我们之前一直在用可迭代对象进行迭代操作. 那么到底什么是可迭代对象. 本小节主要讨论可迭代对象. 首先我们先回顾一下目前我们所熟知的可迭代对象有哪些:</p><p>str, list, tuple, dict, set. 那为什么我们可以称他们为可迭代对象呢? 因为他们都遵循了可迭代协议. 什么是可迭代协议. 首先我们先看一段错误代码:</p><pre><code class="language-python"># 对的s = &quot;abc&quot;for c in s:    print(c)# 错的for i in 123:    print(i)结果:Traceback (most recent call last):  File &quot;/Users/sylar/PycharmProjects/oldboy/iterator.py&quot;, line 8, in &lt;module&gt;    for i in 123:TypeError: 'int' object is not iterable</code></pre><p>注意看报错信息中有这样一句话<code>'int' object is not iterable </code> 翻译过来就是整数类型对象是不可迭代的. <code>iterable</code>表示可迭代的. 表示可迭代协议. 那么如何进行验证你的数据类型是否符合可迭代协议. 我们可以通过<code>dir</code>函数来查看类中定义好的所有方法.</p><pre><code class="language-python">s = &quot;我的哈哈哈&quot;print(dir(s))       # 可以打印对象中的方法和函数print(dir(str))     # 也可以打印类中声明的方法和函数</code></pre><p>在打印结果中. 寻找<code>__iter__ </code>如果能找到. 那么这个类的对象就是一个可迭代对象.</p><pre><code class="language-python">print(&quot;__iter__&quot; in dir(s)) # True</code></pre><p>我们发现在字符串中可以找到<code>__iter__</code>. 继续看一下<code>list</code>,<code> tuple</code>,<code> dict</code>,<code> set</code></p><pre><code class="language-python">print(&quot;__iter__&quot; in dir(tuple)) # Trueprint(&quot;__iter__&quot; in dir(list)) # Trueprint(&quot;__iter__&quot; in dir(open(&quot;护士少妇嫩模.txt&quot;)))  # 文件对象 # Trueprint(&quot;__iter__&quot; in dir(set)) # Trueprint(&quot;__iter__&quot; in dir(dict)) # Trueprint(&quot;__iter__&quot; in dir(int)) # False</code></pre><p>我们发现这几个可以进行for循环的东西都有<code>__iter__</code>函数, 包括<code>range</code>也有. 可以自己试一下.</p><p>这是查看一个对象是否是可迭代对象的第一种办法. 我们还可以通过<code>isinstence()</code>函数来查看一个对象是什么类型的</p><pre><code class="language-python">l = [1,2,3]l_iter = l.__iter__()from collections import Iterablefrom collections import Iteratorprint(isinstance(l,Iterable))    #Trueprint(isinstance(l,Iterator))    #Falseprint(isinstance(l_iter,Iterator))    #Trueprint(isinstance(l_iter,Iterable))    #True</code></pre><p>综上. 我们可以确定. 如果对象中有<code>__iter__</code>函数. 那么我们认为这个对象遵守了可迭代协议. 就可以获取到相应的迭代器. 这里的<code>__iter__</code>是帮助我们获取到对象的迭代器. 我们使用迭代器中的<code>__next__()</code>来获取到一个迭代器中的元素.  那么我们之前讲的for的工作原理到底是什么? 继续看代码</p><pre><code>s = &quot;我爱北京天安门&quot;c = s.__iter__()    # 获取迭代器print(c.__next__())     # 使用迭代器进行迭代. 获取一个元素   我print(c.__next__())     # 爱print(c.__next__())     # 北print(c.__next__())     # 京print(c.__next__())     # 天print(c.__next__())     # 安print(c.__next__())     # 门print(c.__next__())     # StopIteration</code></pre><p>for循环的机制:</p><pre><code class="language-python">for i in [1,2,3]:    print(i)</code></pre><p>使用while循环+迭代器来模拟for循环(必须要掌握)</p><pre><code class="language-python">lst = [1,2,3]lst_iter = lst.__iter__()while True:    try:        i = lst_iter.__next__()        print(i)    except StopIteration:        break</code></pre><p>list可以一次性把迭代器中的内容全部拿空. 并装载在一个新列表中</p><pre><code class="language-python">s = &quot;我要吃饭, 你吃不吃&quot;.__iter__()print(list(s)) # ['我', '要', '吃', '饭', ',', ' ', '你', '吃', '不', '吃']</code></pre><blockquote><p>总结:</p><p>​    <code>Iterable</code>: 可迭代对象. 内部包含<code>__iter__()</code>函数</p><p>​    Iterator: 迭代器. 内部包含<code>__iter__() </code>同时包含<code>__next__()</code></p><p>​     迭代器的特点:</p><p>​       1. 节省内存.</p><p>​       2. 惰性机制</p><p>​       3. 不能反复, 只能向下执行.</p></blockquote><h3 id="生成器"><a class="header-anchor" href="#生成器">¶</a>生成器</h3><p>生成器的本质就是迭代器.  在python中有两种方式来获取生成器:</p><ol><li><p>通过生成器函数 (生成器函数在被执行的的时候。创建生成器  )</p></li><li><p>通过生成器表达式来实现生成器</p></li></ol><p>首先, 我们先看一个很简单的函数:</p><pre><code class="language-python">def func():    print(&quot;111&quot;)    return 222ret = func()print(ret)结果: 111222</code></pre><p>将函数中的return换成yield就是生成器</p><pre><code class="language-python">def func():    print(&quot;111&quot;)    yield 222ret = func()print(ret)结果: &lt;generator object func at 0x10567ff68&gt;</code></pre><p>运行的结果和上面不一样. 为什么呢. 由于函数中存在了yield. 那么这个函数就是一个生成器函数. 这个时候. 我们再执行这个函数的时候. 就不再是函数的执行了. 而是获取这个生成器. 如何使用呢? 想想迭代器. 生成器的本质是迭代器. 所以. 我们可以直接执行<code>__next__()</code>来执行以下生成器.</p><pre><code class="language-python">def func():    print(&quot;111&quot;)    yield 222gener = func()  # 这个时候函数不会执行. 而是获取到生成器ret = gener.__next__()  # 这个时候函数才会执行. yield的作用和return一样. 也是返回数据print(ret)结果: 111222</code></pre><p>那么我们可以看到, yield和return的效果是一样的.  有什么区别呢?  yield是分段来执行一个函数. return呢? 直接停止执行函数.</p><pre><code class="language-python">def func():    print(&quot;111&quot;)    yield 222    print(&quot;333&quot;)    yield 444gener = func()ret = gener.__next__()print(ret)ret2 = gener.__next__()print(ret2)ret3 = gener.__next__()  # 最后一个yield执行完毕. 再次__next__()程序报错, 也就是说. 和return无关了.print(ret3)结果:111Traceback (most recent call last):222333  File &quot;/Users/sylar/PycharmProjects/oldboy/iterator.py&quot;, line 55, in &lt;module&gt;444    ret3 = gener.__next__()  # 最后一个yield执行完毕. 再次__next__()程序报错, 也就是说. 和return无关了.StopIteration</code></pre><p>当程序运行完最后一个yield. 那么后面继续进行__next__()程序会报错.</p><p>好了生成器说完了. 生成器有什么作用呢? 我们来看这样一个需求. 老男孩向JACK JONES订购10000套学生服. JACK JONES就比较实在. 直接造出来10000套衣服.</p><pre><code class="language-python">def cloth():    lst = []    for i in range(0, 10000):        lst.append(&quot;衣服&quot;+str(i))    return lstcl = cloth()</code></pre><p>但是呢, 问题来了. 老男孩现在没有这么多学生啊. 一次性给我这么多. 我往哪里放啊. 很尴尬啊. 最好的效果是什么样呢?  我要1套. 你给我1套. 一共10000套. 是不是最完美的.</p><pre><code class="language-python">def cloth():    for i in range(0, 10000):        yield &quot;衣服&quot;+str(i)cl = cloth()print(cl.__next__())print(cl.__next__())print(cl.__next__())print(cl.__next__())</code></pre><p>区别: 第一种是直接一次性全部拿出来. 会很占用内存. 第二种使用生成器. 一次就一个. 用多少生成多少.  生成器是一个一个的指向下一个.  不会回去, <code>__next__()</code>到哪, 指针就指到哪儿. 下一次继续获取指针指向的值.</p><p>接下来我们来看<code>send</code>方法,<code> send</code>和<code>__next__()</code>一样都可以让生成器执行到下一个<code>yield</code>.</p><pre><code class="language-python">def eat():    print(&quot;我吃什么啊&quot;)    a = yield &quot;馒头&quot;    print(&quot;a=&quot;,a)    b = yield &quot;大饼&quot;    print(&quot;b=&quot;,b)    c = yield &quot;韭菜盒子&quot;    print(&quot;c=&quot;,c)    yield &quot;GAME OVER&quot;gen = eat()     # 获取生成器ret1 = gen.__next__()print(ret1)ret2 = gen.send(&quot;胡辣汤&quot;)print(ret2)ret3 = gen.send(&quot;狗粮&quot;)print(ret3)ret4 = gen.send(&quot;猫粮&quot;)print(ret4)</code></pre><p>send和<code>__next__()</code>区别:</p><ol><li><p>send和next()都是让生成器向下走一次</p></li><li><p>send可以给上一个yield的位置传递值, 不能给最后一个yield发送值. 在第一次执行生成器代码的时候不能使用send()</p></li></ol><p>生成器可以使用for循环来循环获取内部的元素:</p><pre><code class="language-python">def func():    print(111)    yield 222    print(333)    yield 444    print(555)    yield 666gen = func()for i in gen:    print(i)结果:111222333444555666</code></pre><h3 id="列表推导式-生成器表达式以及其他推导式"><a class="header-anchor" href="#列表推导式-生成器表达式以及其他推导式">¶</a>列表推导式, 生成器表达式以及其他推导式</h3><p>给出一个列表, 通过循环, 向列表中添加1-13  :</p><pre><code class="language-python">lst = []for i in range(1, 15):    lst.append(i)print(lst)</code></pre><p>替换成列表推导式:</p><pre><code class="language-python">lst = [i for i in range(1, 15)]print(lst)</code></pre><p>列表推导式是通过一行来构建你要的列表, 列表推导式看起来代码简单. 但是出现错误之后很难排查.</p><p>列表推导式的常用写法:</p><p>[ 结果 for 变量 in 可迭代对象]</p><p>例. 从 pythonx1 一直到pythonx255 写入列表<code>lst</code>:</p><pre><code class="language-python">lst = ['python x %s' % i for i in range(1,255)]print(lst)</code></pre><p>我们还可以对列表中的数据进行筛选</p><p>筛选模式:</p><p>[ 结果 for 变量 in 可迭代对象 if 条件 ]</p><pre><code class="language-python"># 获取1-100内所有的偶数lst = [i for i in range(1, 100) if i % 2 == 0]print(lst)</code></pre><p>列表是不可变的数据类型 故用()得到的不是列表推导式</p><p>生成器表达式和列表推导式的语法基本上是一样的. 只是把[]替换成()</p><pre><code class="language-python">gen = (i for i in range(10))print(gen)结果: &lt;generator object &lt;genexpr&gt; at 0x106768f10&gt;</code></pre><p>打印的结果就是一个生成器. 我们可以使用for循环来循环这个生成器:</p><pre><code class="language-python">gen = (&quot;麻花藤我第%s次爱你&quot; % i for i in range(10))for i in gen:    print(i)</code></pre><p>生成器表达式也可以进行筛选:</p><pre><code class="language-python"># 获取1-100内能被3整除的数gen = (i for i in range(1,100) if i % 3 == 0)for num in gen:    print(num)# 100以内能被3整除的数的平方gen = (i * i for i in range(100) if i % 3 == 0)for num in gen:    print(num)# 寻找名字中带有两个e的人的名字names = [['Tom', 'Billy', 'Jefferson', 'Andrew', 'Wesley', 'Steven', 'Joe'],          ['Alice', 'Jill', 'Ana', 'Wendy', 'Jennifer', 'Sherry', 'Eva']]# 不用推导式和表达式result = []for first in names:    for name in first:        if name.count(&quot;e&quot;) &gt;= 2:            result.append(name)print(result)# 推导式gen = (name for first in names for name in first if name.count(&quot;e&quot;) &gt;= 2)for name in gen:    print(name)</code></pre><p>生成器表达式和列表推导式的区别:</p><ol><li><p>列表推导式比较耗内存. 一次性加载. 生成器表达式几乎不占用内存. 使用的时候才分配和使用内存</p></li><li><p>得到的值不一样. 列表推导式得到的是一个列表. 生成器表达式获取的是一个生成器.</p></li></ol><p>举个栗子.</p><p>同样一篮子鸡蛋. 列表推导式: 直接拿到一篮子鸡蛋.  生成器表达式: 拿到一个老母鸡. 需要鸡蛋就给你下鸡蛋.</p><p>生成器的惰性机制: 生成器只有在访问的时候才取值. 说白了. 你找他要他才给你值. 不找他要. 他是不会执行的.</p><pre><code class="language-python">def func():    print(111)    yield 222g = func()  # 生成器gg1 = (i for i in g) # 生成器g1. 但是g1的数据来源于gg2 = (i for i in g1)    # 生成器g2. 来源g1print(list(g))  # 获取g中的数据. 这时func()才会被执行. 打印111.获取到222. g完毕.print(list(g1))  # 获取g1中的数据. g1的数据来源是g. 但是g已经取完了. g1 也就没有数据了print(list(g2))  # 和g1同理</code></pre><p>深坑==&gt; 生成器. 要值得时候才拿值.</p><p>字典推导式:</p><p>根据名字应该也能猜到. 推到出来的是字典</p><pre><code class="language-python"># 把字典中的key和value互换dic = &#123;'a': 1, 'b': '2'&#125;new_dic = &#123;dic[key]: key for key in dic&#125;print(new_dic)# 在以下list中. 从lst1中获取的数据和lst2中相对应的位置的数据组成一个新字典lst1 = ['jay', 'jj', 'sylar']lst2 = ['周杰伦', '林俊杰', 'jolin']dic = &#123;lst1[i]: lst2[i] for i in range(len(lst1))&#125;print(dic)</code></pre><p>集合推导式:</p><p>集合推导式可以帮我们直接生成一个集合. 集合的特点: 无序, 不重复. 所以集合推导式自带去重功能</p><pre><code class="language-python">lst = [1, -1, 8, -8, 12]# 绝对值去重s = &#123;abs(i) for i in lst&#125;print(s)</code></pre><p>总结: 推导式有, 列表推导式, 字典推导式, 集合推导式, 没有元组推导式</p><p>生成器表达式: (结果 for 变量 in 可迭代对象 if 条件筛选)</p><p>生成器表达式可以直接获取到生成器对象. 生成器对象可以直接进行for循环. 生成器具有惰性机制.</p><p>最后一个知识点: yield from</p><p>在python3中提供了一种可以直接把可迭代对象中的每一个数据作为生成器的结果进行返回</p><pre><code class="language-python">def gen():    lst = [&quot;麻花藤&quot;, &quot;胡辣汤&quot;, &quot;微星牌饼铛&quot;, &quot;Mac牌锅铲&quot;]    yield from lstg = gen()for el in g:print(el)</code></pre><p>小坑: yield from是将列表中的每一个元素返回. 所以. 如果写两个yield from 并不会产生交替的效果.</p><pre><code class="language-python">def gen():    lst = [&quot;麻花藤&quot;, &quot;胡辣汤&quot;, &quot;微星牌饼铛&quot;, &quot;Mac牌锅铲&quot;]    lst2 = [&quot;饼铛还是微星的好&quot;, &quot;联想不能煮鸡蛋&quot;, &quot;微星就可以&quot;, &quot;还可以烙饼&quot;]    yield from lst    yield from lst2g = gen()for el in g:    print(el)效果:麻花藤胡辣汤微星牌饼铛Mac牌锅铲饼铛还是微星的好联想不能煮鸡蛋微星就可以还可以烙饼</code></pre><h4 id="匿名函数-lambda"><a class="header-anchor" href="#匿名函数-lambda">¶</a>匿名函数(lambda )</h4><p>为了解决一些简单的需求而设计的一句话函数</p><pre><code class="language-python"># 计算n的n次方def func(n):    return n**nprint(func(10))f = lambda n: n**nprint(f(10))</code></pre><p>lambda表示的是匿名函数. 不需要用def来声明, 一句话就可以声明出一个函数</p><p>语法:</p><p>函数名 = lambda 参数: 返回值</p><p>注意:</p><ol><li><p>函数的参数可以有多个. 多个参数之间用<strong>逗号</strong>隔开</p></li><li><p>匿名函数不管多复杂. 只能写一行, 且逻辑结束后直接返回数据</p></li><li><p>返回值和正常的函数一样, 可以是任意数据类型</p></li></ol><p>匿名函数并不是说一定没有名字. 这里前面的变量就是一个函数名. 说他是匿名原因是我们通过__name__查看的时候是没有名字的. 统一都叫lambda. 在调用的时候没有什么特别之处. 像正常的函数调用即可</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在学py，简单记录一下笔记&lt;/p&gt;</summary>
    
    
    
    <category term="语言学习" scheme="http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="PYTHON" scheme="http://example.com/tags/PYTHON/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记（3）-函数（1）</title>
    <link href="http://example.com/2022/09/30/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89-%E5%87%BD%E6%95%B0%EF%BC%881%EF%BC%89/"/>
    <id>http://example.com/2022/09/30/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89-%E5%87%BD%E6%95%B0%EF%BC%881%EF%BC%89/</id>
    <published>2022-09-30T10:04:01.901Z</published>
    <updated>2022-10-18T01:38:36.024Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学py，简单记录一下笔记</p><span id="more"></span><h3 id="初识函数"><a class="header-anchor" href="#初识函数">¶</a>初识函数</h3><p>函数: 对代码块和功能的封装和定义</p><p>在<code>py</code>中定义函数的方法：</p><pre><code class="language-python">def 函数名():    函数体</code></pre><p>函数名的命名规则和使用和变量基本一样</p><p>函数体: 就是函数被执行之后要执行的代码</p><p>函数的调用: 使用函数名可以调用函数, 写法: 函数名(), 这个时候函数的函数体会被执行</p><h3 id="函数的返回值"><a class="header-anchor" href="#函数的返回值">¶</a>函数的返回值</h3><p>执行完函数之后. 我们可以使用return来返回结果.</p><p>函数中return的使用:</p><ol><li><p>函数中遇到return, 此函数结束, 不再继续执行.</p></li><li><p>给函数的调用者一个访问结果</p></li><li><p>函数的返回值可以有多个结果,调用者可以接收一个tuple, 调用者可以直接解构成多个变量</p></li><li><p>如果return什么都不写 或者 干脆不写return .那么返回的就是None</p></li></ol><h3 id="函数的参数"><a class="header-anchor" href="#函数的参数">¶</a>函数的参数</h3><p>参数, 函数在调用的时候指定具体的一个变量的值. 就是参数.  语法:</p><pre><code class="language-python">def 函数名(参数列表):    函数体</code></pre><p>关于参数:</p><ol><li>形参</li></ol><p>写在函数声明的位置的变量叫形参.  形式上的一个完整. 表示这个函数需要xxx</p><ol start="2"><li>实参</li></ol><p>在函数调用的时候给函数传递的值. 叫实参, 实际执行的时候给函数传递的信息. 表示给函数xxx</p><ol start="3"><li>传参</li></ol><p>给函数传递信息的时候将实际参数交给形式参数的过程被称为传参.</p><h4 id="实参"><a class="header-anchor" href="#实参">¶</a>实参</h4><h5 id="位置参数"><a class="header-anchor" href="#位置参数">¶</a>位置参数</h5><pre><code class="language-python">def yue(chat, address, age):    # 形参    print(&quot;拿出手机&quot;)    print(&quot;打开&quot;+chat)    print(&quot;找到&quot;+address+&quot;附近的&quot;+str(age)+&quot;好友&quot;)yue(&quot;微信&quot;, &quot;北京&quot;, 18)    # 实参结果:拿出手机打开微信找到北京附近的18岁好友</code></pre><p>按照位置的顺序分别把&quot;微信&quot;, “北京”, 18 赋值给 chat, address, age. 在传参过程中. 系统会默认按照位置把实参赋值到形参.</p><h5 id="关键字参数"><a class="header-anchor" href="#关键字参数">¶</a>关键字参数</h5><p>如果是少量的参数还算OK, 没有问题. 但是如果函数在定义的时候参数非常多怎么办? 程序员必须记住, 我有哪些参数, 而且还有记住每个参数的位置, 否则函数就不能正常调用了. 那则么办呢? python提出了一种叫做关键字参数. 我们不需要记住每个参数的位置. 只要记住每个参数的名字就可以了</p><pre><code class="language-python">def yue(chat, address, age):    # 形参    print(&quot;拿出手机&quot;)    print(&quot;打开&quot;+chat)    print(&quot;找到&quot;+address+&quot;附近的&quot;+str(age)+&quot;好友&quot;)yue(chat=&quot;微信&quot;, age=18, address=&quot;北京)    # 实参结果:拿出手机打开微信找到北京附近的18岁好友</code></pre><h5 id="混合参数"><a class="header-anchor" href="#混合参数">¶</a>混合参数</h5><p>可以把上面两种参数混合着使用. 也就是说在调用函数的时候即可以给出位置参数, 也可以指定关键字参数.</p><pre><code class="language-python">yue(&quot;微信&quot;, age=18, address=&quot;上海&quot;)    # 正确.第一个位置赋值给chat, 后面的参数开始指定关键字.yue(age=&quot;18&quot;, &quot;微信&quot;, address=&quot;广州&quot;)    # 错误, 最开始使用了关键字参数, 那么后面的微信的位置就串了, 容易出现混乱</code></pre><p><u>在使用混合参数的时候, 关键字参数必须在位置参数后面</u></p><h4 id="形参"><a class="header-anchor" href="#形参">¶</a>形参</h4><p>在函数声明的位置编写的变量</p><h5 id="位置参数-v2"><a class="header-anchor" href="#位置参数-v2">¶</a>位置参数</h5><p>按照位置来赋值</p><h5 id="默认值参数"><a class="header-anchor" href="#默认值参数">¶</a>默认值参数</h5><p>在函数声明的时候, 就可以给出函数参数的默认值. 在调用的时候可以给出具体的值, 也可以不给值, 使用默认值.</p><pre><code class="language-python">def stu_info(name, age, sex='男'):    print(&quot;录入学生信息&quot;)    print(name, age, sex)    print(&quot;录入完毕&quot;)stu_info(&quot;张强强&quot;, 18)</code></pre><p><u>必须先声明位置参数, 才能声明默认值参数.</u></p><p>如果默认值参数是一个可变的数据类型，会出现一点小问题</p><pre><code class="language-python">def func(val,lst[]):list.append(val)print(lst)func(1)#第一次输出没有问题 [1]func(2)#两次访问的是同一个列表 [1,2]func(3,[])#[3] </code></pre><p>可变的数据类型,在每次使用的时候都被共享</p><h5 id="动态传参"><a class="header-anchor" href="#动态传参">¶</a>动态传参</h5><p><code>*</code>动态接收位置参数, 在参数位置编写表示接收任意内容，会被打包成元组</p><pre><code class="language-python">def chi(*food):    print(&quot;我要吃&quot;, food)chi(&quot;大米饭&quot;, &quot;小米饭&quot;)结果:我要吃 ('大米饭', '小米饭')    # 多个参数传递进去. 收到的内容是元组tuple</code></pre><p>动态接收参数的时候要注意: 动态参数必须在位置参数后面</p><pre><code class="language-python">def chi(*food, a, b):    print(&quot;我要吃&quot;, food, a, b)chi(&quot;大米饭&quot;, &quot;小米饭&quot;, &quot;黄瓜&quot;, &quot;茄子&quot;)</code></pre><p><strong>这时程序运行会报错. 因为前面传递进去的所有位置参数都被*food接收了. a和b永远接收不到参数</strong></p><p>可以这样改写</p><pre><code class="language-python">def chi(*food, a, b):    print(&quot;我要吃&quot;, food, a, b)chi(&quot;大米饭&quot;, &quot;小米饭&quot;, a=&quot;黄瓜&quot;, b=&quot;茄子&quot;)   # 必须用关键字参数来指定</code></pre><p>或者先写位置参数，再用动态参数</p><p><code>**</code>动态接收关键字参数</p><p>在python中可以动态的位置参数, 但是*这种情况只能接收位置参数无法接收关键字参数. 在python中使用**来接收动态关键字参数</p><pre><code class="language-python">def func(**kwargs):    print(kwargs)func(a=1, b=2, c=3)func(a=1, b=2)结果:&#123;'a': 1, 'b': 2, 'c': 3&#125;&#123;'a': 1, 'b': 2&#125;</code></pre><p><strong>顺序的问题</strong>  在函数调用的时候, 如果先给出关键字参数, 则整个参数列表会报错.</p><p>所以关键字参数必须在位置参数后面. 由于实参是这个顺序. 所以形参接收的时候也是这个顺序. 也就是说位置参数必须在关键字参数前面. 动态接收关键字参数也要在后面</p><p>*<em>最终顺序(<em>重点):</em></em></p><p>​     位置参数 &gt; <code> *args</code> &gt; 默认值参数 &gt; <code>**kwargs</code></p><p>​     <strong>这四种参数可以任意的进行使用. 如果想接收所有的参数:</strong></p><pre><code class="language-python">def func(*args, **kwargs):    print(args, kwargs)func(&quot;麻花藤&quot;,&quot;马晕&quot;,wtf=&quot;胡辣汤&quot;)</code></pre><p>动态参数的另一种传参方式:</p><pre><code class="language-python">def fun(*args):    print(args)lst = [1, 4, 7]fun(lst[0], lst[1], lst[2])fun(*lst)   # 可以使用*把一个列表按顺序打散s = &quot;臣妾做不到&quot;fun(*s)     # 字符串也可以打散, (可迭代对象)</code></pre><p>在实参位置上给一个序列,列表,可迭代对象前面加个*表示把这个序列按顺序打散.</p><p>在形参的位置上的* 表示把接收到的参数组合成一个元组</p><p>如果是一个字典, 那么也可以打散. 不过需要用两个*</p><pre><code class="language-python">def fun(**kwargs):    print(kwargs)dic = &#123;'a':1, 'b':2&#125;fun(**dic)</code></pre><h4 id="函数的注释"><a class="header-anchor" href="#函数的注释">¶</a>函数的注释</h4><pre><code class="language-python">def chi(food, drink):    &quot;&quot;&quot;    这里是函数的注释, 先写一下当前这个函数是干什么的, 比如我这个函数就是一个吃    :param food: 参数food是什么意思    :param drink: 参数drink是什么意思    :return: 返回的是什么东东    &quot;&quot;&quot;    print(food, drink)    return &quot;very good&quot;</code></pre><h3 id="函数的嵌套和作用域"><a class="header-anchor" href="#函数的嵌套和作用域">¶</a>函数的嵌套和作用域</h3><p>作用域: 一个变量能使用的作用范围</p><p>仔细分析以下代码.</p><pre><code class="language-python">a = 10  # 函数外面有个adef func():    a = 20  # 函数里面也有个a    print(a)  #  此时打印的结果?func()   #  此时打印的结果?</code></pre><p>注意, 在python中. 你可以认为变量的使用是遵循就近原则的.</p><p>在函数外面的变量被称为全局变量. 它的作用域是整个py文件.  在函数内部的变量被称为局部变量.作用范围仅限于函数内部.</p><p>我们可以通过<code>globals()</code>和<code>locals()</code>查看全局和局部作用域中的内容</p><pre><code class="language-python">a = 10def func():    a = 40    b = 20    def abc():        print(&quot;哈哈&quot;)    print(a, b)     # 这里使用的是局部作用域    print(globals())    # 打印全局作用域中的内容    print(locals())     # 打印局部作用域中的内容func()</code></pre><p><code>globals()</code>查看全局作用域</p><p><code>locals()</code>查看当前作用域</p><p>函数与函数之间可以互相的调用. 也可以互相的嵌套</p><pre><code class="language-python">def fun1():    print(111)   def fun2():    print(222)    fun1()   fun2()print(111)# 函数的嵌套def fun2():    print(222)    def fun3():        print(666)    print(444)    fun3()    print(888)    print(33)fun2()print(555)</code></pre><h3 id="global和nonlocal关键字"><a class="header-anchor" href="#global和nonlocal关键字">¶</a>global和nonlocal关键字</h3><pre><code class="language-python">a = 100def func():    a += 1  # 报错.      print(a)func()print(a)</code></pre><p>注意报错那句话</p><p>这句话相当于a = a + 1 先计算右边. 右边会把全局变量a引入进来使用. 然后重新赋值给a. 但是，python中不允许函数内部改变外面变量的值. 这样做很不安全. python规定. 在函数内部想要修改全局变量. 必须使用global关键字把外面的变量引入才可以进行修改(赋值).</p><pre><code class="language-python">a = 100def func():    global a    a += 1       print(a)func()print(a) # 101</code></pre><p>相同的. nonlocal也是一样的操作. 它负责在内层函数中引入外层函数的局部变量</p><pre><code class="language-python">a = 10def func1():    a = 20    def func2():        nonlocal a #  有它没它两个结果        a = 30        print(a)    func2()    print(a)func1()结果:加了nonlocal3030不加nonlocal3020</code></pre><p>python程序在加载的时候，会给解释器内置需要的一些变量加载，加载的位置叫内置名称空间</p><p>接下来就开始执行自己的py文件，自己创建的这些变量统一放在全局名称空间中</p><p>当程序执行到函数的时候，函数内部会有自己的变量，Python会为每一个正在执行的函数单独开辟内存，该内存被称为局部名称空间</p><p><img src="/images/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89-%E5%87%BD%E6%95%B0%EF%BC%881.1%EF%BC%89.png" alt="image-20220929133108221"></p><p><img src="/images/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89-%E5%87%BD%E6%95%B0%EF%BC%881.2%EF%BC%89.png" alt="image-20220929133501169"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在学py，简单记录一下笔记&lt;/p&gt;</summary>
    
    
    
    <category term="语言学习" scheme="http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="PYTHON" scheme="http://example.com/tags/PYTHON/"/>
    
  </entry>
  
  <entry>
    <title>有向图的拓扑排序</title>
    <link href="http://example.com/2022/09/26/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2022/09/26/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</id>
    <published>2022-09-26T09:26:41.816Z</published>
    <updated>2022-10-17T15:42:40.557Z</updated>
    
    <content type="html"><![CDATA[<p>在生活中，有些事物可以用有向无环图（DAG）表示，这种有向无环图也被称之为“流程图”。比如：施工流程图，生产流程图，图中的每一个顶点代表着一项具体的工序，每条有向边则反应了两个工序的前后次序。</p><span id="more"></span><h2 id="有向图的拓扑排序"><a class="header-anchor" href="#有向图的拓扑排序">¶</a>有向图的拓扑排序</h2><p>比如《数据结构》一书中，给出的这个生活中的案例：</p><p><img src="/images/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%881%EF%BC%89.jpg" alt="image-20220926172838381"></p><p>拓扑排序（TorpSort）是指用有向图中各个顶点构成有序序列。</p><p>上面的列子经过拓扑排序后就可以是这样的：</p><p><img src="/images/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%882%EF%BC%89.jpg" alt="image-20220926172838381"></p><p>之后要科普两个点，以便更好的理解DAG</p><p>入度：有多少条边指向自己</p><p>出度：向外指了多少条边</p><p>我们根据已知可以推断出DAG的一些特点：</p><ul><li>一个有向无环图至少存在一个入度为0的点</li><li>如果每个顶点的入度都大于0，那么它必然存在回路</li></ul><p>那么对于拓扑排序，我们可否有以下思路：</p><p>只要想找到任何一个入度为0的点，然后输出该顶点，并从图中删除改顶点以及与其相连的所有边（相当于挖墙脚，即便删除掉该点原图还是一个DAG）。对改变后的图重复这一过程，知道所以有顶点输出为止。这个输出的顶点的序列就是我们要找的拓扑排序后的序列。</p><p>综合考虑，这个题用邻接表的方式写比较好，下面用的是acwing上y总宽搜的模板，数组模拟链表和队列：</p><pre><code class="language-c++">//模拟链表int h[N], e[N], ne[N], idx;//在输入的时候要注意记录入度的数量int d[N];//模拟队列int q[N];bool topsort()&#123;    //初始化 头节点置空     memset(h, -1, sizeof h);        //模拟队列    int hh = 0, tt = -1;    // d[i] 存储点i的入度     for (int i = 1; i &lt;= n; i ++ )        if (!d[i])            //将元素的下标添加进入队尾            q[ ++ tt] = i;    //循环结束条件 队列中元素为空    while (hh &lt;= tt)    &#123;        //取出队头        int t = q[hh ++ ];//按照队头遍历链表        for (int i = h[t]; ~i ; i = ne[i])        &#123;            int j = e[i];            //删除一个点后入度为0的点 将其加入序列中            if (-- d[j] == 0)                q[ ++ tt] = j;        &#125;    &#125;    //若为topsort则队列长度应该刚好等于序列长度    return tt == n-1;&#125;</code></pre><p>参考某位大佬给的比较完整的解法</p><pre><code class="language-c++">  #include &quot;stdafx.h&quot;  #include&lt;stdio.h&gt;  #include&lt;string.h&gt;  #define MAXNODE 20  typedef struct  &#123;    char vertex;  &#125;VerNode;   typedef struct  &#123;    int adj;  &#125;Arc;   typedef struct  &#123;    VerNode vexs[MAXNODE];    Arc arcs[MAXNODE][MAXNODE];    int m_numOfVexs;  &#125;Graph;   int mFind(char aim, VerNode* arry)  &#123;    int pos=-1;    int i=0;    for(i=0; i&lt;MAXNODE; i++)    &#123;      if(aim==arry[i].vertex)      &#123;        pos=i;        return pos;      &#125;    &#125;    return pos;  &#125;   void showGraph(Graph aGraph, int num)  &#123;    int i=0;    int j=0;    printf(&quot;\n NODES:\n&quot;);    for(i=0; i&lt;num; i++)    &#123;      printf(&quot; %c&quot;, aGraph.vexs[i].vertex);    &#125;    printf(&quot;\n ARCS:\n&quot;);    for(i=0; i&lt;num; i++)    &#123;      for(j=0; j&lt;num; j++)      &#123;        printf(&quot; %d&quot;, aGraph.arcs[i][j].adj);      &#125;      printf(&quot; \n&quot;);    &#125;  &#125;   //添加顶点  void addVexs(Graph* aGraph, char vex)  &#123;    aGraph-&gt;m_numOfVexs++;    aGraph-&gt;vexs[aGraph-&gt;m_numOfVexs].vertex=vex;  &#125;   //添加边  void addArcs(Graph* aGraph, char aStart, char aEnd)  &#123;    int p_x=mFind(aStart,aGraph-&gt;vexs);    int p_y=mFind(aEnd,aGraph-&gt;vexs);    aGraph-&gt;arcs[p_x][p_y].adj=1;  &#125;   //图的初始化  void initGraph(Graph* aGraph)  &#123;    int i=0;    int j=0;    aGraph-&gt;m_numOfVexs=-1;    for(i=0; i&lt;MAXNODE; i++)    &#123;      for(j=0; j&lt;MAXNODE; j++)        aGraph-&gt;arcs[i][j].adj=0;    &#125;  &#125;   int getInDegree(int i, Graph* aGraph)  &#123;    int InDegree=0;    int j=0;    for(j=0; j&lt;aGraph-&gt;m_numOfVexs; j++)      InDegree+=aGraph-&gt;arcs[j][i].adj;    return InDegree;  &#125;   int topSort(Graph* aGraph)  &#123;    int i;    int isOK=1;    int vexsIsOut[MAXNODE];    for(i=0; i&lt;aGraph-&gt;m_numOfVexs; i++)    &#123;      vexsIsOut[i]=0;    &#125;    while(isOK==1)    &#123;      isOK=0;      for(i=0; i&lt;aGraph-&gt;m_numOfVexs; i++)      &#123;        if(vexsIsOut[i]==0&amp;&amp;getInDegree(i,aGraph)==0)        &#123;          int j;          printf(&quot;%c &quot;,aGraph-&gt;vexs[i].vertex);          vexsIsOut[i]=1;          for(j=0; j&lt;aGraph-&gt;m_numOfVexs; j++)          &#123;            aGraph-&gt;arcs[i][j].adj=0;          &#125;          isOK=1;        &#125;      &#125;    &#125;    for(i=0; i&lt;aGraph-&gt;m_numOfVexs; i++)    &#123;      if(vexsIsOut[i]==0)        return 0;    &#125;    return 1;  &#125;   int main(void)  &#123;    char node='a';    char input1='a';    char input2='a';    //将图初始化    Graph g_graph;    initGraph(&amp;g_graph);     //根据用户的输入添加顶点    printf(&quot;Please input the vexs( end with #):\n&quot;);    while(1)    &#123;      if(node=='#')        break;      if(scanf(&quot;%c,&quot;,&amp;node)==1)      &#123;        if(node=='\n')          continue;        addVexs(&amp;g_graph,node);      &#125;    &#125;     //根据用户的输入添加边    printf(&quot;Please input arcs, just like this \&quot;startNod,endNode\&quot; \n&quot;);    while(1)    &#123;      if(input1=='#')        break;      if(scanf(&quot;%c,%c&quot;,&amp;input1, &amp;input2)==2)      &#123;        if(input1=='\n'||input2=='\n')          continue;        addArcs(&amp;g_graph, input1, input2);      &#125;    &#125;     //输出图    showGraph(g_graph, g_graph.m_numOfVexs);     printf(&quot;The topsort is: \n&quot;);    if(topSort(&amp;g_graph)==0)      printf(&quot;There is a circle in the graph!! \n&quot;);    return 0;  &#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;在生活中，有些事物可以用有向无环图（DAG）表示，这种有向无环图也被称之为“流程图”。比如：施工流程图，生产流程图，图中的每一个顶点代表着一项具体的工序，每条有向边则反应了两个工序的前后次序。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="others" scheme="http://example.com/tags/others/"/>
    
    <category term="ALGO" scheme="http://example.com/tags/ALGO/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记（2）基础数据类型</title>
    <link href="http://example.com/2022/09/15/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/"/>
    <id>http://example.com/2022/09/15/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</id>
    <published>2022-09-15T08:10:15.811Z</published>
    <updated>2022-09-24T06:53:37.742Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学py，简单记录一下笔记</p><span id="more"></span><h2 id="格式化输出"><a class="header-anchor" href="#格式化输出">¶</a>格式化输出</h2><p>放置占位符，再把字符串里的占位符与外部的变量做好映射关系</p><pre><code class="language-python">name = input(&quot;Name:&quot;) age = input(&quot;Age:&quot;) job = input(&quot;Job:&quot;) hobby = input(&quot;Hobbie:&quot;) info = ''' ------------ info of %s ----------- #这里的每个%s就是一个占位符，本行的代表 后面拓号里的 name Name : %s #代表 name Age  : %s #代表 age  job  : %s #代表 job Hobbie: %s #代表 hobbie ------------- end ----------------- ''' % (name,name,age,job,hobbie) # 这行的 % 号就是 把前面的字符串 与拓号 后面的 变量 关联起来 print(info)         </code></pre><p><u>注意空格</u></p><p>%s就是代表字符串占位符，除此之外，还有%d, 是数字占位符， 如果把上面的age后面的换成%d，就代表你必须只能输入数字啦, 这时对应的数据必须是int类型. 否则程序会报错使用时,需要进行类型转换.</p><pre><code class="language-python">int(str)   # 字符串转换成int str(int)   # int转换成字符串      </code></pre><blockquote><p>在字符串中如果使用了%s这样的占位符. 那么所有的%都将变成占位符需要使用%%来表示字符串中的%</p></blockquote><p>python3.5以后可以使用f来格式化字符串.</p><p>语法 : <code>f&quot;&#123;变量&#125;&quot;</code></p><pre><code class="language-python">name = &quot;sylar&quot; print(f&quot;&#123;name&#125;真是一个...&quot;)         </code></pre><p>​</p><h2 id="基本运算符"><a class="header-anchor" href="#基本运算符">¶</a>基本运算符</h2><h4 id="算术运算"><a class="header-anchor" href="#算术运算">¶</a>算术运算</h4><p><img src="/images/%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97.png" alt="image-20220915164625454"></p><h4 id="比较运算"><a class="header-anchor" href="#比较运算">¶</a>比较运算</h4><p><img src="/images/%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97.png" alt="image-20220915164937061"></p><h4 id="赋值运算"><a class="header-anchor" href="#赋值运算">¶</a>赋值运算</h4><p><img src="/images/%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97.png" alt="image-20220915165015281"></p><h4 id="逻辑运算"><a class="header-anchor" href="#逻辑运算">¶</a>逻辑运算</h4><p><img src="/images/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97.png" alt="image-20220915165046443"></p><p>and 并且 and左右两端同时为真，结果才为真</p><p>or 或者 两端有一个为真结果为真</p><p>not 非 非真即假，非假即真</p><p><strong>逻辑运算的运算顺序: () &gt; not &gt; and &gt; or</strong></p><h4 id="成员运算"><a class="header-anchor" href="#成员运算">¶</a>成员运算</h4><p><code>xx in xxx</code> 表示xx是否不在xxx中出现</p><p><code>xx not...in xxx</code>   表示xx是否不在xxx中出现</p><h2 id="编码初识以及bytes"><a class="header-anchor" href="#编码初识以及bytes">¶</a>编码初识以及bytes</h2><ol><li>ascii : 8bit, 主要存放的是英文, 数字,  特殊符号</li><li>gbk: 16bit, 主要存放中文和亚洲字符. 兼容ascii</li><li>unicode: 16bit和32bit两个版本. 平时我们用的是16bit这个版本. 全世界所有国家的文字信息. 缺点: 浪费空间(传输和存储)</li><li>utf-8 : 可变长度unicode, 英文: 8bit, 欧洲文字: 16bit, 中文24bit. 一般数据传输和存储的时候使用.</li><li>以上所有编码必须兼容ascii .</li></ol><p>内存中使用的是unicode ，一个/x就是一个字节，一个汉字三个字节</p><p>gbk中，一个汉字两个字节</p><p><u>编码用encode()  解码用decode()</u></p><p>不同的编码之间是不能进行转换的，若想转换，可以先解码再编码</p><p>一个字节8个0和1</p><h2 id="基础数据类型bool"><a class="header-anchor" href="#基础数据类型bool">¶</a>基础数据类型bool</h2><p>所有表示空的东西都是False</p><p>基本数据类型之间的转化, 想变成谁, 就用谁把数据括起来</p><h2 id="基础数据类型str"><a class="header-anchor" href="#基础数据类型str">¶</a>基础数据类型str</h2><p>把字符连成串. 在python中用’, &quot;, ‘’', “”&quot;引起来的内容被称为字符串.</p><p>字符串: 把多个字符连成串</p><h4 id="字符串索引和切片"><a class="header-anchor" href="#字符串索引和切片">¶</a>字符串索引和切片</h4><p>索引从0开始</p><p>切片:</p><p>s[start: end: step]</p><p>start: 起始位置</p><p>end: 结束位置, 取不到</p><p>step: 步长（步长如果是负数，从右往左取数字）.</p><h4 id="常用API"><a class="header-anchor" href="#常用API">¶</a>常用API</h4><ol><li><p>upper(), 把字符串中所有的字母都变成大写. 主要使用在忽略大小写的时候用</p></li><li><p>strip(), 默认去掉左右两端的空白, 包括\n, \t, 空格.</p></li><li><p>replace(), 字符串替换</p></li><li><p>split(),  字符串切割. 得到字符串列表</p></li><li><p>join(),  把列表重新组合成字符串</p><pre><code class="language-python">lst = ['周杰伦', '王力宏', '麻花藤'] s = &quot;_&quot;.join(lst) print(s)  # 周杰伦_王力宏_麻花藤           </code></pre></li><li><p>startswith(),  判断是否以xxxx开头</p></li><li><p>endwith(),判断是否以xx结尾</p></li><li><p>find(), 查找xxxx</p></li><li><p>index()，求索引位置，如果找不到系统会报错</p></li><li><p>count(), 数数, 查看xxx出现的次数</p></li><li><p>isdigit(), 判断该字符串是否是由数字组成</p></li><li><p>len(), 字符串长度, 它是一个内置函数, 直接len(数据)即可</p></li><li><p>capitalize(),首字母变成大写</p></li><li><p>dir(),能查看这个数据类型能执行哪些操作</p></li></ol><pre><code class="language-python">for 变量 in 可迭代对象（不能放数字在这里）:循环体</code></pre><h4 id="关于in"><a class="header-anchor" href="#关于in">¶</a>关于in</h4><pre><code class="language-python">   in有两种用法:     1. 在for中. 是把每一个元素获取到赋值给前面的变量.    2. 不在for中. 判断xxx是否出现在str中.  print('VUE' in s19)      </code></pre><h4 id="字符串的格式化输出"><a class="header-anchor" href="#字符串的格式化输出">¶</a>字符串的格式化输出</h4><pre><code class="language-python">name = 'Jay'age = 8s1 = &quot;我叫%s,我今年%d岁了&quot; % (name,age)print(s1)s2 = f&quot;我叫&#123;name&#125;,我今年&#123;age&#125;岁了&quot;print(s2)#按照位置格式化s3 = &quot;我叫&#123;&#125;,我今年&#123;&#125;岁了&quot;.format(name,age)print(s3)#按照函数中参数顺序分别填入对应相应的参数，从0开始，不得越界s4 = &quot;我叫&#123;1&#125;,我今年&#123;0&#125;岁了&quot; .format(name,age)print(s4)s5 = &quot;我叫&#123;aname&#125;,我今年&#123;aage&#125;岁了&quot; .format(aname=name,aage=age)print(s5)</code></pre><p><u>字符串是不可变的对象, 所以任何操作对原字符串是不会有任何影响的</u></p><h2 id="基础数据类型list"><a class="header-anchor" href="#基础数据类型list">¶</a>基础数据类型list</h2><p>列表是python的基础数据类型之一 ,其他编程语言也有类似的数据类型. 比如JS中的数组, java中的数组等等. 它是以[ ]括起来, 每个元素用’ , '隔开而且可以存放各种数据类型.</p><p>列表相比于字符串. 不仅可以存放不同的数据类型. 而且可以存放大量的数据. 32位python可以存放: 536870912个元素, 64位可以存放: 1152921504606846975个元素.而且列表是有序的(按照你保存的顺序),有索引, 可以切片方便取值.</p><h4 id="索引和切片"><a class="header-anchor" href="#索引和切片">¶</a>索引和切片</h4><p>和字符串中索引和切片操作基本相同，不同的是列表中的数据类型是list</p><p><u>列表是一个可变的数据类型</u></p><h4 id="列表查常用操作"><a class="header-anchor" href="#列表查常用操作">¶</a>列表查常用操作</h4><h5 id="增加"><a class="header-anchor" href="#增加">¶</a>增加</h5><p>注意, list和str是不一样的. list可以发生改变. 所以直接就在原来的对象上进行了操作</p><p>append的效率高于insert</p><pre><code class="language-python">lst = [&quot;麻花藤&quot;, &quot;林俊杰&quot;, &quot;周润发&quot;, &quot;周芷若&quot;] print(lst) lst.append(&quot;wusir&quot;) print(lst) lst = [] while True:       content = input(&quot;请输入你要录入的员工信息, 输入Q退出:&quot;)       if content.upper() == 'Q':             break       lst.append(content) print(lst) lst = [&quot;麻花藤&quot;, &quot;张德忠&quot;, &quot;孔德福&quot;] lst.insert(1, &quot;刘德华&quot;)  # 在1的位置插入刘德华. 原来的元素向后移动一位 print(lst) # 迭代添加 lst = [&quot;王志文&quot;, &quot;张一山&quot;, &quot;苦海无涯&quot;] lst.extend([&quot;麻花藤&quot;, &quot;麻花不疼&quot;]) print(lst)          </code></pre><h5 id="删除"><a class="header-anchor" href="#删除">¶</a>删除</h5><p>pop, remove, clear, del</p><pre><code class="language-python">lst = [&quot;麻花藤&quot;, &quot;王剑林&quot;, &quot;李嘉诚&quot;, &quot;王富贵&quot;] print(lst) deleted = lst.pop()     # 默认删除最后一个 print(&quot;被删除的&quot;, deleted) print(lst) el = lst.pop(2)   # 删除2号元素 print(el) print(lst) lst.remove(&quot;麻花藤&quot;)  # 删除指定元素 print(lst) # lst.remove(&quot;哈哈&quot;)  # 删除不存在的元素会报错 # print(lst) lst.clear()   # 清空list print(lst) # 切片删除 del lst[1:3] print(lst)   </code></pre><h5 id="修改"><a class="header-anchor" href="#修改">¶</a>修改</h5><p>索引切片修改</p><pre><code class="language-python"># 修改lst = [&quot;得儿得儿&quot;, &quot;太牛&quot;, &quot;胡辣汤&quot;, &quot;王者荣耀&quot;, &quot;科科&quot;] lst[1] = &quot;太污&quot;  # 把1号元素修改成太污 print(lst) lst[1:4:3] = [&quot;麻花藤&quot;, &quot;哇靠&quot;]   # 切片修改也OK. 如果步长不是1, 要注意. 元素的个数 print(lst) lst[1:4] = [&quot;压了个嘿嘿&quot;] # 如果切片没有步长或者步长是1. 则不用关心个数 print(lst)    </code></pre><h5 id="查询"><a class="header-anchor" href="#查询">¶</a>查询</h5><p>列表是一个可迭代对象, 所以可以进行for循环</p><pre><code class="language-python">for el in lst:       print(el)     </code></pre><h5 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h5><pre><code class="language-python">lst = [&quot;小白&quot;, &quot;小黑&quot;, &quot;腾哥&quot;, &quot;马总&quot;, &quot;日天&quot;, &quot;小白&quot;] c = lst.count(&quot;小白&quot;)   # 查询太白出现的次数 print(c) lst = [1, 11, 22, 2] lst.sort()     # 排序. 默认升序 print(lst) lst.sort(reverse=True) # 降序 print(lst) lst = [&quot;小白&quot;, &quot;小黑&quot;, &quot;腾哥&quot;, &quot;马总&quot;, &quot;日天&quot;, &quot;白天&quot;] print(lst) lst.reverse() #翻转print(lst) l = len(lst)  # 列表的长度 print(l) #rang（让for循环去数数,顾头不顾尾）for num in range(10):    print(num)#输出0,1,...10for num in range(10, 1, -2):    # 反着来, 和切片一样    print(num)    #range最大的作用是可以循环出列表中每一个元素的索引lst = [&quot;周杰伦&quot;, &quot;马虎疼&quot;, &quot;疼不疼&quot;]for i in range(len(lst)):    print(i, lst[i])</code></pre><h4 id="列表的嵌套"><a class="header-anchor" href="#列表的嵌套">¶</a>列表的嵌套</h4><pre><code class="language-python">lst = [1, &quot;小白&quot;, &quot;小黑黑&quot;, [&quot;马虎疼&quot;, [&quot;可口可乐&quot;], &quot;王剑林&quot;], 'kounijiwa'] # 找到小白和小黑黑 print(lst[1:3]) # 找到小白的白字 print(lst[1][1]) # 将kounijiwa拿到. 然后首字母大写. 再扔回去 s = lst[4] s = s.capitalize() lst[4] = s print(lst) # 简写 lst[4] = lst[4].capitalize() print(lst) # 把马虎疼换成马化疼 lst[3][0] = lst[3][0].replace(&quot;虎&quot;, &quot;化&quot;) #lst[3][0].replace(&quot;虎&quot;, &quot;化&quot;) 产生一个新的字符串，要将字符串替换到原来的位置print(lst[3][0]) lst[3][1].append(&quot;雪碧&quot;) print(lst)     </code></pre><h2 id="基础数据类型tuple"><a class="header-anchor" href="#基础数据类型tuple">¶</a>基础数据类型tuple</h2><p>只读列表，元组也是python的基本数据类型之一, 用小括号括起来, 里面可以放任何数据类型的数据,  查询可以. 循环也可以. 切片也可以. 但就是不能改.</p><pre><code class="language-python">tu = (1, &quot;太白&quot;, &quot;李白&quot;, &quot;太黑&quot;, &quot;怎么黑&quot;) print(tu)print(tu[2:5]) # 切片之后还是元组 # for循环遍历元组 for el in tu:   print(el) # 尝试修改元组 # tu[1] = &quot;马虎疼&quot;  # 报错 'tuple' object does not support item assignment tu = (1, &quot;哈哈&quot;, [], &quot;呵呵&quot;) # tu[2] = [&quot;fdsaf&quot;]   这么改不行 tu[2].append(&quot;麻花藤&quot;)   # 可以改了. 没报错 print(tu)     </code></pre><p><strong><u>这里元组的不可变的意思是子元素不可变，元组内存的指向不可变. 而子元素内部的子元素是可以变, 这取决于子元素是否是可变对象.</u></strong></p><p><u>元组中如果只有一个元素. 一定要添加一个逗号, 否则就不是元组</u></p><pre><code class="language-python">tu = (1,) print(type(tu))     </code></pre><p>​</p><h2 id="基础数据类型dict"><a class="header-anchor" href="#基础数据类型dict">¶</a>基础数据类型dict</h2><p>字典(<code>dict</code>)是python中唯一的一个映射类型.他是以{ }括起来的键值对组成. 在<code>dict</code>中key是唯一的. 在保存的时候, 根据key来计算出一个内存地址. 然后将<code>key:value</code>保存在这个地址中. 这种算法被称为hash算法, 所以, 切记, 在<code>dict</code>中存储的<code>key:value</code>中的key’必须是可hash的, 如果你搞不懂什么是可哈希, 暂时可以这样记, 可以改变的都是不可哈希的, 那么可哈希就意味着不可变. 这个是为了能准确的计算内存地址而规定的.</p><p>已知的可哈希(不可变)的数据类型: int, str, tuple, bool</p><p>不可哈希(可变)的数据类型: list, dict, set</p><p>语法 :</p><p>{key1: value1, key2: value2…}</p><blockquote><p>注意:</p><p>key必须是不可变(可哈希)的. value没有要求.可以保存任意类型的数据</p><p>dict保存的数据不是按照我们添加进去的顺序保存的. 是按照hash表的顺序保存的. 而hash表不是连续的. 所以不能进行切片工作. 它只能通过key来获取dict中的数据</p></blockquote><h4 id="字典增删改查和其他操作"><a class="header-anchor" href="#字典增删改查和其他操作">¶</a>字典增删改查和其他操作</h4><p>增加</p><pre><code class="language-python">dic = &#123;&#125;dic['name'] = '周润发'     # 如果dict中没有出现这个key, 就会新增一个key-value的组合进dictprint(dic)# 如果dict中没有出现过这个key-value,key必须是不存在的. 可以通过setdefault设置默认值dic.setdefault('李嘉诚')   # 也可以往里面设置值.dic.setdefault(&quot;李嘉诚&quot;, &quot;房地产&quot;)    # 如果dict中已经存在了. 那么setdefault将不会起作用print(dic)</code></pre><p>删除(参考列表，没有remove)</p><pre><code class="language-python">ret = dic.pop(&quot;jay&quot;)#pop中加上keyprint(ret)del dic[&quot;jay&quot;]print(dic)# 清空字典中的所有内容dic.clear()</code></pre><p>修改</p><pre><code class="language-python">dic = &#123;&quot;id&quot;: 123, &quot;name&quot;: 'sylar', &quot;age&quot;: 18&#125;dic1 = &#123;&quot;id&quot;: 456, &quot;name&quot;: &quot;麻花藤&quot;, &quot;ok&quot;: &quot;wtf&quot;&#125;dic.update(dic1)    # 把dic1中的内容更新到dic中. 如果key重名. 则修改替换. 如果不存在key, 则新增.print(dic)</code></pre><p>查询（根据是否确定该key存在选择使用）</p><pre><code class="language-python">print(dic['name']) # 不存在 报错print(dic.get(&quot;sylar&quot;))      # 不存在 返回Noneprint(dic.get(&quot;sylar&quot;, &quot;牛B&quot;))   # 牛B#setdefault 在执行完新增流程后，会根据key查询valueprint(dic.setdefault(&quot;sylar&quot;))   </code></pre><p>循环</p><pre><code class="language-python">dic = &#123;&quot;id&quot;: 123, &quot;name&quot;: 'sylar', &quot;age&quot;: 18, &quot;ok&quot;: &quot;科比&quot;&#125;#第一种for k in dic:    print(k)    # dict.keys(['id', 'name', 'age', 'ok']) 不用管它是什么.当成list来用就行for key in dic.keys():    print(key)# dict.values([123, 'sylar', 18, '科比']) 当list来用for value in dic.values():    print(value)# dict_items([('id', 123), ('name', 'sylar'), ('age', 18), ('ok', '科比')]) 这个东西也是list. 只不过list中装的是tuplefor key, value in dic.items(): #解构    print(key, value)# 解构a = 1, 2print(a) #类型是元组（1,2）(c, d) = 3, 4print(c, d)#分别输出3,4 类型都是int# 解构的时候注意数量必须匹配 错误写法 最多两个元素e, f = [1, 2, 3]    print(e, f)</code></pre><h4 id="字典的嵌套"><a class="header-anchor" href="#字典的嵌套">¶</a>字典的嵌套</h4><pre><code class="language-python">dic1 = &#123;    &quot;name&quot;: &quot;汪峰&quot;,    &quot;age&quot;: 18,    &quot;wife&quot;: &#123;        &quot;name&quot;: '章子怡',        &quot;age&quot;: 28    &#125;,    &quot;children&quot;: ['第一个毛孩子', '第二个毛孩子'],    &quot;desc&quot;: '峰哥不会告我吧. 没关系. 我想上头条的'&#125;print(dic1.get(&quot;wife&quot;).get(&quot;name&quot;))print(dic1.get(&quot;children&quot;)[1])</code></pre><h2 id="基本数据类型Set"><a class="header-anchor" href="#基本数据类型Set">¶</a>基本数据类型Set</h2><p>set集合是python的一个基本数据类型. 一般不是很常用. set中的元素是不重复的.无序的.里面的元素必须是可hash的(int, str, tuple,bool), 我们可以这样来记. set就是<code>dict</code>类型的数据但是不保存value, 只保存key. set也用{}表示</p><p><code>add</code> 增加</p><p><code>remove</code>修改 先把要修改的内容删除，然后新增一个新的</p><p>最主要的操作: 去重复, 交,并,差</p><pre><code class="language-python">s1 = &#123;&quot;刘能&quot;, &quot;赵四&quot;, &quot;皮长山&quot;&#125;s2 = &#123;&quot;刘科长&quot;, &quot;冯乡长&quot;, &quot;皮长山&quot;&#125;# 交集# 两个集合中的共有元素print(s1 &amp; s2)  # &#123;'皮长山'&#125;print(s1.intersection(s2))  # &#123;'皮长山'&#125;# 并集print(s1 | s2)  # &#123;'刘科长', '冯乡长', '赵四', '皮长山', '刘能'&#125;print(s1.union(s2))     # &#123;'刘科长', '冯乡长', '赵四', '皮长山', '刘能'&#125;# 差集print(s1 - s2)  # &#123;'赵四', '刘能'&#125; 得到第一个中单独存在的print(s1.difference(s2))     # &#123;'赵四', '刘能'&#125;</code></pre><h2 id="深浅copy"><a class="header-anchor" href="#深浅copy">¶</a>深浅copy</h2><pre><code class="language-python">lst1 = [&quot;金毛狮王&quot;, &quot;紫衫龙王&quot;, &quot;白眉鹰王&quot;, &quot;青翼蝠王&quot;]#并没有产生新的对象 而是把原来的内存地址 赋给list2lst2 = lst1print(lst1)print(lst2)lst1.append(&quot;杨逍&quot;)print(lst1)print(lst2)结果:['金毛狮王', '紫衫龙王', '白眉鹰王', '青翼蝠王', '杨逍']['金毛狮王', '紫衫龙王', '白眉鹰王', '青翼蝠王', '杨逍']#可以通过 id(list1) 来查看list1的地址dic1 = &#123;&quot;id&quot;: 123, &quot;name&quot;: &quot;谢逊&quot;&#125;dic2 = dic1print(dic1)  # &#123;'id': 123, 'name': '谢逊'&#125;print(dic2)  # &#123;'id': 123, 'name': '谢逊'&#125;dic1['name'] = &quot;范瑶&quot;print(dic1)  # &#123;'id': 123, 'name': '范瑶'&#125;print(dic2)  # &#123;'id': 123, 'name': '范瑶'&#125;</code></pre><h4 id="浅拷贝"><a class="header-anchor" href="#浅拷贝">¶</a>浅拷贝</h4><pre><code class="language-python">lst1 = [&quot;何炅&quot;, &quot;杜海涛&quot;,&quot;周渝民&quot;]lst2 = lst1.copy()lst1.append(&quot;李嘉诚&quot;)print(lst1)print(lst2)print(id(lst1), id(lst2))结果: 两个lst完全不一样. 内存地址和内容也不一样. 发现实现了内存的拷贝lst1 = [&quot;何炅&quot;, &quot;杜海涛&quot;,&quot;周渝民&quot;, [&quot;麻花藤&quot;, &quot;马芸&quot;, &quot;周笔畅&quot;]]lst2 = lst1.copy()lst1[3].append(&quot;无敌是多磨寂寞&quot;)print(lst1)print(lst2)print(id(lst1[3]), id(lst2[3]))结果: ['何炅', '杜海涛', '周渝民', ['麻花藤', '马芸', '周笔畅', '无敌是多磨寂寞']]['何炅', '杜海涛', '周渝民', ['麻花藤', '马芸', '周笔畅', '无敌是多磨寂寞']]4417248328 4417248328</code></pre><p>只会拷贝第一层. 第二层的内容不会拷贝，还是指向原地址. 所以被称为浅拷贝</p><h4 id="深拷贝"><a class="header-anchor" href="#深拷贝">¶</a>深拷贝</h4><p>必须使用copy模块</p><pre><code class="language-python">import copylst1 = [&quot;何炅&quot;, &quot;杜海涛&quot;,&quot;周渝民&quot;, [&quot;麻花藤&quot;, &quot;马芸&quot;, &quot;周笔畅&quot;]]lst2 = copy.deepcopy(lst1)lst1[3].append(&quot;无敌是多磨寂寞&quot;)print(lst1)print(lst2)print(id(lst1[3]), id(lst2[3]))结果:['何炅', '杜海涛', '周渝民', ['麻花藤', '马芸', '周笔畅', '无敌是多磨寂寞']]['何炅', '杜海涛', '周渝民', ['麻花藤', '马芸', '周笔畅']]4447221448 4447233800</code></pre><p>深度拷贝. 把元素内部的元素完全进行拷贝复制. 不会产生一个改变另一个跟着改变的问题</p><h2 id="知识点补充"><a class="header-anchor" href="#知识点补充">¶</a>知识点补充</h2><h4 id="列表和字典循环的时候不能删除"><a class="header-anchor" href="#列表和字典循环的时候不能删除">¶</a>列表和字典循环的时候不能删除</h4><p>python中的列表和字典在循环的时候. 不能删除自身中的元素. 列表虽然不报错，但是删不干净.  对于字典, 直接报错. 不让删. 解决方案都一样, 把要删除的内容保存在一个新列表中, 循环新列表, 删除老列表.</p><p>每次remove后，后面的元素都会向前挪，但是指针位置还是不变的，导致前挪动的元素，如果符合条件，就不会被删除</p><pre><code class="language-python">lst = [&quot;张无忌&quot;, &quot;张翠山&quot;, &quot;灭绝师太&quot;, &quot;胡辣汤&quot;]new_lst = []for name in lst:    if name.startswith(&quot;张&quot;):        new_lst.append(name)#法一        for name in new_lst:    lst.remove(name)#法二 新产生的字符串与原字符串指向同一地址for name in lst[:]:    if name.startswith('张'):        lst.remove(name)        print(lst) # [&quot;灭绝师太&quot;, &quot;胡辣汤&quot;] </code></pre><p>字典操作与列表类似，可以选择存储keys</p><h4 id="is和-的区别"><a class="header-anchor" href="#is和-的区别">¶</a>is和==的区别</h4><p>== 判断的是内容. ==&gt;  两个人长的是不是一样?</p><p>is   判断的是内存地址.  ==&gt;  两个人是不是同一个人</p><p><u>此结论不适合字符串.</u></p><h4 id="while…else"><a class="header-anchor" href="#while…else">¶</a>while…else</h4><pre><code class="language-python">while 条件:    循环体else: 循环在正常情况跳出之后会执行这里</code></pre><p>如果循环是通过break退出的. 那么while后面的else将不会被执行, 只有在while条件判断是假的时候才会执行这个else</p><p><code>pass</code>: <u>不表示任何内容. 为了代码的完整性.  占位而已</u></p><h2 id="文件操作"><a class="header-anchor" href="#文件操作">¶</a>文件操作</h2><p><code>               f = open(文件, mode=&quot;模式&quot; encoding=&quot;编码&quot;)             </code></p><p>f被称为文件句柄，负责操纵你打开的这个文件</p><h4 id="模式"><a class="header-anchor" href="#模式">¶</a>模式:</h4><p>r: 只读</p><p>w: 只写  如果没有文件. 则会创建文件, 如果文件存在. 则将原件中原来的内容删除, 再写入新内容</p><pre><code class="language-python">f.write(&quot;\n&quot;) 换行</code></pre><p>a: 追加写    追加写，不会重新创建文件，但是如果文件不存在，可以创建文件</p><p>+: 扩展      不是很好用</p><p>b: 字节(非文本文件，可理解为二进制文件，不能指定encoding)</p><pre><code class="language-python">#s实现文件复制f1=open(&quot;a/tu.jpg&quot;,mode=&quot;rb&quot;)f2=open(&quot;c/yu.jpg&quot;,mode=&quot;wb&quot;)for line in f1:f2.write(line)</code></pre><h4 id="读取文件的方法"><a class="header-anchor" href="#读取文件的方法">¶</a>读取文件的方法</h4><ol><li>read()  将文件中的内容全部读取出来. 弊端: 占内存. 如果文件过大.容易导致内存崩溃</li><li>read(n) 读取n个字符. 需要注意的是. 如果再次读取. 那么会在当前位置继续去读而不是从头读, 如果使用的是rb模式. 则读取出来的是n个字节</li><li>readline() 一次读取一行数据, 注意: readline()结尾, 注意每次读取出来的数据都会有一个\n 所以呢. 需要我们使用strip()方法来去掉\n或者空格</li><li>readlines()将每一行形成一个元素, 放到一个列表中. 将所有的内容都读取出来. 所以也是. 容易出现内存崩溃的问题.不推荐使用</li><li>循环读取 读取文件最好的方案</li></ol><pre><code class="language-python">#另一种写法，可以不用`close` 使用with()自动加入 '\'可以用来表示一行的连接    with open() as f1,\     open() as f2:        for line in f1:            f2.write(line)            print(line.strip())#去掉换行xxxxx</code></pre><p><strong>读取完的文件句柄一定要关闭 <code> f.close()</code>，</strong></p><p>​</p><h4 id="修改文件"><a class="header-anchor" href="#修改文件">¶</a>修改文件:</h4><ol><li>创建一个文件副本.</li><li>把源文件中的内容读取到内存.</li><li>然后在内存中进行修改.</li><li>修改之后保存在文件副本中.</li><li>把源文件删除</li><li>把文件副本更改名称为源文件的名称</li></ol><pre><code class="language-python"># 文件修改import oswith open(&quot;小娃娃&quot;, mode=&quot;r&quot;, encoding=&quot;utf-8&quot;) as f1,\     open(&quot;小娃娃_new&quot;, mode=&quot;w&quot;, encoding=&quot;UTF-8&quot;) as f2:    content = f1.read()    new_content = content.replace(&quot;冰糖葫芦&quot;, &quot;大白梨&quot;)    f2.write(new_content)os.remove(&quot;小娃娃&quot;)    # 删除源文件os.rename(&quot;小娃娃_new&quot;, &quot;小娃娃&quot;)     # 重命名新文件</code></pre><p>弊端: 一次将所有内容进行读取. 内存溢出. 解决方案: 一行一行的读取和操作</p><pre><code class="language-python">import oswith open(&quot;小娃娃&quot;, mode=&quot;r&quot;, encoding=&quot;utf-8&quot;) as f1,\     open(&quot;小娃娃_new&quot;, mode=&quot;w&quot;, encoding=&quot;UTF-8&quot;) as f2:    for line in f1:        new_line = line.replace(&quot;大白梨&quot;, &quot;冰糖葫芦&quot;)        f2.write(new_line)os.remove(&quot;小娃娃&quot;)    # 删除源文件os.rename(&quot;小娃娃_new&quot;, &quot;小娃娃&quot;)     # 重命名新文件</code></pre><p>​</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在学py，简单记录一下笔记&lt;/p&gt;</summary>
    
    
    
    <category term="语言学习" scheme="http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="PYTHON" scheme="http://example.com/tags/PYTHON/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记（1）入门</title>
    <link href="http://example.com/2022/09/15/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
    <id>http://example.com/2022/09/15/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</id>
    <published>2022-09-15T01:50:59.963Z</published>
    <updated>2022-09-15T08:54:21.123Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学py，简单记录一下笔记</p><span id="more"></span><p>IDLE 常用的快捷键</p><table><thead><tr><th>含义</th><th>快捷键</th></tr></thead><tbody><tr><td>增加代码块缩进</td><td>Ctrl+]</td></tr><tr><td>减少代码块缩进</td><td>Ctrl+[</td></tr><tr><td>注释代码块</td><td>Alt+3</td></tr><tr><td>取消代码块注释</td><td>Alt+4</td></tr><tr><td>浏览上一条输入的命令</td><td>Alt+p</td></tr><tr><td>浏览下一条输入的命令</td><td>Alt+n</td></tr><tr><td>补全单词，列出全部可选单词供选择</td><td>Tab</td></tr></tbody></table><ul><li>Python中对空格的应用很严格 运算时 运算符要与其他数据加上空格隔开</li></ul><h3 id="注释"><a class="header-anchor" href="#注释">¶</a>注释</h3><p>单行注释<code>#</code></p><p>多行注释<code>'''</code>3 个单引号<code>&quot;&quot;&quot;</code>3 个双引号</p><h3 id="变量以及变量命名规范"><a class="header-anchor" href="#变量以及变量命名规范">¶</a>变量以及变量命名规范</h3><p>标识符是在程序中用来标识诸如变量、函数、类、对象等名字的符号。在 Python 中，<br>用标识符来标识变量，变量在使用前都必须被赋值，变量被赋值后变量才会被创建。在 Python<br>中，变量是用一个变量名表示，也就是一个标识符来表示，变量名的命名规则：</p><p>（1）变量名只能是字母、数字或下划线的任意组合。<br>（2）变量名的第一个字符不能是数字。<br>（3） Python 关键字不能声明为变量名：</p><p>推荐使用驼峰体或者下划线命名</p><blockquote><p>驼峰体: 除首字母外的其他每个单词首字母大写</p><p>下划线: 每个单词之间用下划线分开</p></blockquote><p><strong>类型属于对象，变量是没有类型的，变量只是对象的引用，所谓变量的类型指的是变量所引用的对象的类型。变量的类型随着所赋值的类型的变化而改变。</strong></p><p>变量的数据类型:</p><p>int, 整数, 加减乘除, 余数, 整除</p><p>str, 字符串, ‘, &quot;, ‘’’, “”&quot;都是字符串, 操作: +, *</p><p>bool，布尔值. True, False</p><p>​</p><h3 id="常量"><a class="header-anchor" href="#常量">¶</a>常量</h3><p>Python中不存在绝对的常量，只要字母大写就是常量</p><h3 id="用户交互"><a class="header-anchor" href="#用户交互">¶</a>用户交互</h3><p><code>input()</code></p><p><strong>input获取到数据都是字符串类型, 如果想要进行数学运算或者比较. 必须转化成int()</strong></p><h3 id="条件分支"><a class="header-anchor" href="#条件分支">¶</a>条件分支</h3><pre><code class="language-python">if 条件:    # 引号是将条件与结果分开。结果   # 四个空格，或者一个tab键，这个是告诉程序满足这个条件的   elif 条件2:   结果2... else:   结果n </code></pre><p>当条件成立. 执行相应的结果.</p><p>​</p><h3 id="循环分支"><a class="header-anchor" href="#循环分支">¶</a>循环分支</h3><pre><code class="language-python">while 条件:   循环体 </code></pre><p>只要条件成立. 就一直执行循环体. 每次执行完循环体. 重新判断条件</p><h3 id="流程控制-break和continue"><a class="header-anchor" href="#流程控制-break和continue">¶</a>流程控制-break和continue</h3><p><code>break</code>: 立刻跳出循环. 打断的意思.</p><p><code>continue</code>: 结束当前这一次循环，跳过后面可能存在的信息，即继续执行下一次循环</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在学py，简单记录一下笔记&lt;/p&gt;</summary>
    
    
    
    <category term="语言学习" scheme="http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="PYTHON" scheme="http://example.com/tags/PYTHON/"/>
    
  </entry>
  
  <entry>
    <title>C++ STL简介</title>
    <link href="http://example.com/2022/09/05/C++%20STL%E7%AE%80%E4%BB%8B/"/>
    <id>http://example.com/2022/09/05/C++%20STL%E7%AE%80%E4%BB%8B/</id>
    <published>2022-09-05T13:33:15.027Z</published>
    <updated>2022-09-15T01:59:48.363Z</updated>
    
    <content type="html"><![CDATA[<p>C/C++常用stl及api用法</p><span id="more"></span><p>每个容器都有的api</p><p><code>size() </code> 返回元素个数 O(1)</p><p><code> empty()</code>  返回是否为空O(1)</p><p><code>clear()</code> 清空队列无O(n)</p><h3 id="vector"><a class="header-anchor" href="#vector">¶</a>vector</h3><p>vector, 变长数组，倍增的思想<br><code>clear()</code>  清空<br><code>front()/back()</code>取队头或者对位<br><code>push_back()/pop_back()</code>  插入最后一个数\删除最后一个数<br>``begin()/end()`  迭代器</p><p>​    支持比较运算，按字典序</p><blockquote><p>定义一个长度为n,ing且里面的每一个数字都初始化为m的vector数组</p><p><code>vector&lt;int&gt; a(n,m)</code></p><p>系统为某一程序分配空间时所需时间，与空间大小无关，与申请所需要的次数有关</p><p>vector具有空间不足，自动扩容（倍增）的机制，并且完成自我复制</p></blockquote><h3 id="pair-int-int"><a class="header-anchor" href="#pair-int-int">¶</a>pair&lt;int, int&gt;</h3><p>相当于二元结构体，并内置比较函数</p><p>​    <code>first</code>, 第一个元素<br>​    <code>second</code>, 第二个元素<br>​    支持比较运算，以<code>first</code>为第一关键字，以<code>second</code>为第二关键字（字典序）</p><h3 id="string，字符串"><a class="header-anchor" href="#string，字符串">¶</a>string，字符串</h3><p>​    <code>length()</code>  返回字符串长度<br>​    <code>substr(起始下标，(子串长度))</code>  返回子串<br><code>c_str()</code> 返回字符串所在字符数组的起始地址</p><h3 id="queue-队列"><a class="header-anchor" href="#queue-队列">¶</a>queue, 队列</h3><p><code>push()</code>  向队尾插入一个元素<br><code>front()</code>  返回队头元素<br><code>back()</code>  返回队尾元素<br><code>pop()</code>  弹出队头元素</p><h3 id="priority-queue"><a class="header-anchor" href="#priority-queue">¶</a>priority_queue</h3><p>priority_queue, 优先队列，默认是大根堆</p><p>​    <code>push()</code>  插入一个元素<br><code>top()</code>  返回堆顶元素<br>​    <code>pop()</code>  弹出堆顶元素<br>​    定义成小根堆的方式：<code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q</code>;</p><blockquote><p>greater表示内置类型从大到小排序，less表示内置类型从小到大排序。</p></blockquote><h3 id="stack-栈"><a class="header-anchor" href="#stack-栈">¶</a>stack, 栈</h3><p><code>push()</code>  向栈顶插入一个元素</p><p><code> top()</code>  返回栈顶元素</p><p><code> pop()</code>  弹出栈顶元素</p><h3 id="deque-双端队列"><a class="header-anchor" href="#deque-双端队列">¶</a>deque, 双端队列</h3><p>效率很低撒~</p><p>​    <code>front()/back()</code><br>​    <code>push_back()/pop_back()</code><br>​    <code>push_front()/pop_front()</code><br>​    <code>begin()/end()</code><br>​</p><h3 id="set-map-multiset-multimap"><a class="header-anchor" href="#set-map-multiset-multimap">¶</a>set, map, multiset, multimap</h3><p>基于平衡二叉树（红黑树），动态维护有序序列</p><p>​    <code>size()</code><br>​    <code>empty()</code><br>​    <code>clear()</code><br>​    <code>begin()/end()</code><br>​    <code>++, --</code> 返回前驱和后继，时间复杂度 O(logn)</p><h4 id="set-multiset"><a class="header-anchor" href="#set-multiset">¶</a>set/multiset</h4><p><code>insert()</code>  插入一个数</p><p><code>find()</code>  查找一个数</p><p><code>count()</code>  返回某一个数的个数</p><p><code> erase()</code></p><ol><li><p>输入一个数x，删除所有xO(k+logn) k是个数</p></li><li><p>输入一个迭代器，删除这个迭代器</p></li><li><p>​        输入是一个数x，删除所有x   O(k + logn)</p></li><li><p>​        输入一个迭代器，删除这个迭代器</p></li></ol><p><code> lower_bound()/upper_bound()</code><br><code>lower_bound(x)</code>  返回大于等于x的最小的数的迭代器<br><code> upper_bound(x)</code>  返回大于x的最小的数的迭代器</p><h4 id="map-multimap"><a class="header-anchor" href="#map-multimap">¶</a>map/multimap</h4><p>​    <code>insert()</code>  插入的数是一个pair（表现为映射）<br><code> erase()</code>  输入的参数是pair或者迭代器<br>​    <code>find()</code><br>​     注意multimap不支持此操作。 时间复杂度是 O(logn)<br>​    <code>lower_bound()/upper_bound()</code></p><h4 id="unordered-set-unordered-map-unordered-multiset-unordered-multimap-哈希表"><a class="header-anchor" href="#unordered-set-unordered-map-unordered-multiset-unordered-multimap-哈希表">¶</a>unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</h4><p>​内部无序</p><p>​    和上面类似，增删改查的时间复杂度是 O(1)<br>​    不支持 <code>lower_bound()/upper_bound()</code>， 迭代器的++，–</p><h3 id="bitset-圧位"><a class="header-anchor" href="#bitset-圧位">¶</a>bitset, 圧位</h3><p>省八位空间</p><blockquote><p>bitset是一个多位二进制数，每八位占用一个字节，因为支持基本的位运算，所以可用于状态压缩，n位bitset执行一次位运算的时间复杂度可视为n/32.</p><p><code>bitset&lt;10000&gt; s;</code></p></blockquote><p>支持的符号操作</p><p><code> ~, &amp;, |, ^</code><br><code> &gt;&gt;, &lt;&lt;</code><br><code>==, !=</code></p><p><code>count()</code>  返回有多少个1</p><p><code>any()</code>  判断是否至少有一个1<br><code>none()</code>  判断是否全为0</p><p><code>set() </code> 把所有位置成1<br><code>set(k, v)</code>  将第k位变成v<br><code>reset()</code>  把所有位变成0<br><code>flip()</code>  等价于~<br><code>flip(k)</code> 把第k位取反</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;C/C++常用stl及api用法&lt;/p&gt;</summary>
    
    
    
    <category term="语言学习" scheme="http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C/C++" scheme="http://example.com/tags/C-C/"/>
    
    <category term="others" scheme="http://example.com/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>堆排序（数组模拟）</title>
    <link href="http://example.com/2022/09/04/%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%EF%BC%89/"/>
    <id>http://example.com/2022/09/04/%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%EF%BC%89/</id>
    <published>2022-09-04T07:07:17.328Z</published>
    <updated>2022-09-15T02:06:56.514Z</updated>
    
    <content type="html"><![CDATA[<p>堆是特殊的队列，特殊的点就在于它可以依照元素的优先级取出，而不是元素入队的先后顺序。</p><span id="more"></span><p>堆常表现为完全二叉树的形式，因为高度为h的完全二叉树有结点 2<sup>(k-1)到2</sup>k-1个，且结点排布极共规律，因此，通常不必用指针，而是用数组来实现堆的存储。</p><p><img src="/images/%E5%A0%86%E6%8E%92%E5%BA%8F.png" alt="image-20220904145447744"></p><p>堆排序核心操作，建堆</p><pre><code class="language-c++">void down(int u)&#123;int t=u;//构建平衡二叉搜索树if( 2*u&lt;=cnt &amp;&amp; h[2*u]&lt;h[t] ) t=2*u;if( 2*u+1 &lt;= cnt &amp;&amp; h[2*u+1]&lt;h[t]) t=2*u+1;//代表树的位置已经发生变化,递归直到u==t时结束if(u!=t)&#123;    swap(h[u],h[t]);    down(t);&#125;&#125;</code></pre><p>只要理解平衡二叉树的原理就好</p><p>完整代码</p><pre><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e5+10;int n,m;//cnt记录结点数，h数组模拟树int cnt,h[N];void down(int u)&#123;int t=u;if( 2*u&lt;=cnt &amp;&amp; h[2*u]&lt;h[t] ) t=2*u;if( 2*u+1 &lt;= cnt &amp;&amp; h[2*u+1]&lt;h[t]) t=2*u+1;if(u!=t)&#123;    swap(h[u],h[t]);    down(t);&#125;&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n ,&amp;m );    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;h[i]);//更新cntcnt=n;//从树顶开始向下递归for (int i = n/2; i ; i -- )down(i);while (m -- )&#123;    printf(&quot;%d &quot;,h[1]);    //保证每次输出的顶都是最小的    h[1]=h[cnt--];    down(1);&#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;堆是特殊的队列，特殊的点就在于它可以依照元素的优先级取出，而不是元素入队的先后顺序。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="http://example.com/tags/C-C/"/>
    
    <category term="others" scheme="http://example.com/tags/others/"/>
    
    <category term="ALGO" scheme="http://example.com/tags/ALGO/"/>
    
  </entry>
  
  <entry>
    <title>算法学习的一些零碎知识点</title>
    <link href="http://example.com/2022/08/28/%E9%9B%B6%E9%9B%B6%E7%A2%8E%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://example.com/2022/08/28/%E9%9B%B6%E9%9B%B6%E7%A2%8E%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2022-08-28T10:00:20.602Z</published>
    <updated>2022-09-05T09:48:10.473Z</updated>
    
    <content type="html"><![CDATA[<p>随笔记录一下日常学习遇到的points</p><span id="more"></span><h3 id="无穷大"><a class="header-anchor" href="#无穷大">¶</a>无穷大</h3><p>在算法竞赛中，我们常常需要用到设置一个常量用来代表“无穷大”。</p><p>比如对于int类型的数，有的人会采用INT_MAX，即0x7fffffff作为无穷大。但是以INT_MAX为无穷大常常面临一个问题，即加一个其他的数会溢出。</p><p>而这种情况在动态规划，或者其他一些递推的算法中常常出现，很有可能导致算法出问题。</p><p>所以在算法竞赛中，我们常采用0x3f3f3f3f来作为无穷大。0x3f3f3f3f主要有如下好处：</p><p>0x3f3f3f3f的十进制为1061109567，和INT_MAX一个数量级，即10<sup>9数量级，而一般场合下的数据都是小于10</sup>9的。<br>0x3f3f3f3f * 2 = 2122219134，无穷大相加依然不会溢出。<br>可以使用memset(array, 0x3f, sizeof(array))来为数组设初值为0x3f3f3f3f，因为这个数的每个字节都是0x3f。</p><h3 id="memset"><a class="header-anchor" href="#memset">¶</a>memset</h3><p>memset函数是按照字节直接来对数组进行赋值，比如h为一个int类型数组，有四个字节<br><code>memset( h , 0x3f ,sizeof h )</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随笔记录一下日常学习遇到的points&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="others" scheme="http://example.com/tags/others/"/>
    
    <category term="ALGO" scheme="http://example.com/tags/ALGO/"/>
    
  </entry>
  
  <entry>
    <title>c语言中的&amp;的用法</title>
    <link href="http://example.com/2022/08/28/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84&amp;%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://example.com/2022/08/28/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84&amp;%E7%9A%84%E7%94%A8%E6%B3%95/</id>
    <published>2022-08-28T08:36:26.279Z</published>
    <updated>2022-08-28T11:59:38.329Z</updated>
    
    <content type="html"><![CDATA[<p>在做题时，经常会看到在数字或者字符串前面加上&amp;，之前一直没太注意这个单目&amp;，下面总结一下&amp;的用法。😗</p><span id="more"></span><h3 id="取地址（指针赋值）"><a class="header-anchor" href="#取地址（指针赋值）">¶</a>取地址（指针赋值）</h3><p>个人认为c语言中，比较不容易理解的就是指针了。</p><p>举一个该情况下使用&amp;的例子</p><pre><code class="language-c">#include&lt;stdio.h&gt;int main()&#123;    int a = 2;        int*b;//定义一个整形指针        b = &amp;a;//给指针赋值，使指针指向a的地址        printf(&quot;%d&quot;, b);//输出的是a的地址    printf(&quot;%d&quot;, *b);//*的作用是解引用，取出指针指向地址的内容,本例里输出的是2    return 0;&#125;</code></pre><p>由于使用&amp;（引用）的时候，跟原数指向的是一个地址，故也不会造成每次使用都新开辟一个内存，相当于JAVA中的静态变量</p><p>比如接下来在Tire中的一个<code>insert</code>操作（将相应的数字存储在Tire上，以便于接下来的操作）</p><pre><code class="language-c">void insert(int x)&#123;    int p=0;    for (int i = 30; ~i ; i -- )&#123;        int &amp;s=son[p][x&gt;&gt;i&amp;1];        if(!s) s=++idx;        p=s;    &#125;&#125;</code></pre><p>这里在定义s时，如果不加第一个引用（第二个&amp;是与操作，接下来会讲），只能代表son[p][x&gt;&gt;i&amp;1]中存储的数值，而在这里使用了引用 就相当于以下操作</p><pre><code class="language-c">void insert(int x)&#123;    int p=0;    for (int i = 30; ~i ; i -- )&#123;        int &amp;s=son[p][x&gt;&gt;i&amp;1];        if(!son[p][x&gt;&gt;i&amp;1]) son[p][x&gt;&gt;i&amp;1]=++idx;        p=son[p][x&gt;&gt;i&amp;1];    &#125;&#125;</code></pre><p>是不是很省代码！</p><h3 id="位操作中的与操作运算符"><a class="header-anchor" href="#位操作中的与操作运算符">¶</a><a href="https://so.csdn.net/so/search?q=%E4%BD%8D%E6%93%8D%E4%BD%9C&amp;spm=1001.2101.3001.7020">位操作</a>中的与操作运算符</h3><p>&amp;是单目运算符，按位与运算通常用来对某些位清0或保留某些位</p><p>计算的时候按位计算，&amp;两边操作数对应位上全为1时，结果的该位值为1。否则该位值为0</p><h3 id="逻辑与运算"><a class="header-anchor" href="#逻辑与运算">¶</a>逻辑与运算</h3><p>&amp;&amp;就是常说的and操作，双目运算符</p><p>逻辑运算结果只有0和1两种结果。 一般在&amp;&amp;两边是两个逻辑表达式。当两个表达式值均为1时，<br>&amp;&amp;运算结果为1，否则为0。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在做题时，经常会看到在数字或者字符串前面加上&amp;amp;，之前一直没太注意这个单目&amp;amp;，下面总结一下&amp;amp;的用法。😗&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="http://example.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="C/C++" scheme="http://example.com/tags/C-C/"/>
    
    <category term="others" scheme="http://example.com/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法详解</title>
    <link href="http://example.com/2022/08/27/KMP%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/08/27/KMP%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-08-27T06:15:37.460Z</published>
    <updated>2022-08-28T01:49:08.802Z</updated>
    
    <content type="html"><![CDATA[<p>几个月前学过一次kmp，因为太愚笨，没有搞明白暂时放弃了，这几天又开始看，终于搞明白了，再次记录一下我的理解😎</p><span id="more"></span><h3 id="BF算法-O-n-m"><a class="header-anchor" href="#BF算法-O-n-m">¶</a>BF算法 O(n*m)</h3><p><strong>模式匹配</strong>：子串的定位运算成为串的模式匹配或串匹配</p><blockquote><p>假设有两个串 S、T，设S为主串，也称正文串：T为子串，也称模式。在主串 S中查找<br>与模式 T相匹配的子串，如果查找成功，返回匹配的子串第一个字符在主串中的位置。<br>最笨的办法就是穷举所有 S的所有子串，判断是否与T匹配，该算法称为 BF ( Brute<br>Force）算法。</p></blockquote><p>BF算法的思想就是将目标串S的第一个字符与模式串T的第一个字符进行匹配，若相等，则继续比较S的第二个字符和T的第二个字符；若不相等，则比较S的第二个字符和T的第一个字符，依次比较下去，直到得出最后的匹配结果。</p><p>算法实现（C语言版本）</p><pre><code class="language-c">#include &lt;stdio.h&gt;#include&lt;string.h&gt;//strA是主串，strB是子串int mate(char *strA, char *strB) &#123;    int i, j;    i = j = 0;    while (i &lt; strlen(strA) &amp;&amp; j &lt; strlen(strB)) &#123;        if(strA[i]==strB[j])&#123;            i++;            j++;        &#125; else&#123;            i=i-j+1;            j=0;        &#125;    &#125;    //判断字串情况如果到最后则遍历完毕找到匹配位置    if(j== strlen(strB))&#123;        return i-j+1;    &#125;    return 0;&#125;</code></pre><p>可以看出 bf算法本身是没有什么技巧在的 就是简单的暴力枚举 故当数据范围比较大时 bf算法就不再适用</p><h3 id="改进的KMP算法"><a class="header-anchor" href="#改进的KMP算法">¶</a>改进的KMP算法</h3><p>实际上，完全没必要从S的每一个字符开始穷举每一种情况，某K，M，P名字开头的三位大佬对上述算法进行改进，并提出了KMP算法。</p><p>需要了解一些基本概念：</p><ol><li><p>s[ ]是模式串，即比较长的字符串。</p></li><li><p>p[ ]是模板串，即比较短的字符串。</p></li><li><p>前缀：从前往后取若干个字符。</p></li><li><p>后缀：从后往前取若干个字符。</p></li><li><p>部分匹配值：前缀和后缀的最长共有元素的长度。</p></li><li><p>next[ ]是“部分匹配值表”，即next数组，它存储的是每一个下标对应的“部分匹配值”，是<strong>KMP算法的核心</strong>。（后面作详细讲解）。</p></li></ol><p>核心思想：在每次失配时，不是把p串往后移一位，而是把p串往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找next[ ]数组确定的。</p><h4 id="next数组的含义："><a class="header-anchor" href="#next数组的含义：">¶</a>next数组的含义：</h4><p>对next[ j ] ，是p[ 1, j ]串中前缀和后缀相同的最大长度（部分匹配值），即 p[ 1, next[ j ] ] = p[ j - next[ j ] + 1, j ]。</p><p>如：</p><p>手动模拟求next数组：</p><p>对 p = “abcab”</p><table><thead><tr><th>p</th><th>a</th><th>b</th><th>c</th><th>a</th><th>b</th></tr></thead><tbody><tr><td>下标</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td>next[ ]</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td></tr></tbody></table><p>对next[ 1 ] ：前缀 = 空集—————后缀 = 空集—————next[ 1 ] = 0;</p><p>对next[ 2 ] ：前缀 = { a }—————后缀 = { b }—————next[ 2 ] = 0;</p><p>对next[ 3 ] ：前缀 = { a , ab }—————后缀 = { c , bc}—————next[ 3 ] = 0;</p><p>对next[ 4 ] ：前缀 = { a , ab , abc }—————后缀 = { a . ca , bca }—————next[ 4 ] = 1;</p><p>对next[ 5 ] ：前缀 = { a , ab , abc , abca }————后缀 = { b , ab , cab , bcab}————next[ 5 ] = 2;</p><h4 id="KMP主要分两步：求next数组、匹配字符串。"><a class="header-anchor" href="#KMP主要分两步：求next数组、匹配字符串。">¶</a>KMP主要分两步：求next数组、匹配字符串。</h4><p>先说一下如何求 next数组</p><p>next数组其实就是求模板串的相同前后缀的长度</p><p>算法实现：</p><pre><code class="language-c">for(int i = 2, j = 0; i &lt;= m; i++)&#123;    while(j &amp;&amp; p[i] != p[j+1]) j = next[j];    if(p[i] == p[j+1]) j++;        next[i] = j;&#125;</code></pre><p>可以写出通用公式</p><p>​{ 0 ,  j=1</p><p>next[j]=  { lmax+1 , T的相等前缀后缀的最大程度为lmax</p><p>​{ 1 , 没有相等前缀后缀</p><p>求匹配字符串</p><p>算法实现（c语言版本）</p><pre><code class="language-c">for(int i = 1, j = 0; i &lt;= n; i++)&#123;    while(j &amp;&amp; s[i] != p[j+1]) j = ne[j];    //如果j有对应p串的元素， 且s[i] != p[j+1], 则失配， 移动p串    //用while是由于移动后可能仍然失配，所以要继续移动直到匹配或整个p串移到后面（j = 0)    if(s[i] == p[j+1]) j++;    //当前元素匹配，j移向p串下一位    if(j == m)    &#123;        //匹配成功，进行相关操作        j = next[j];  //继续匹配下一个子串    &#125;&#125;</code></pre><p>将上述两个代码合并就是KMP算法的代码实现啦</p><pre><code class="language-c">for (int i = 2,j=0; i &lt;= n; i ++ )&#123;        while(j&amp;&amp;p[i]!=p[j+1]) j=ne[j];      if(p[i]==p[j+1]) j++;        ne[i]=j;&#125;for (int i = 1,j=0; i &lt;= m; i ++ )&#123;    while( j &amp;&amp; s[i]!= p[j+1]) j=ne[j];        if(s[i]==p[j+1]) j++;        if(j==n)&#123;        j=ne[j];                printf(&quot;%d &quot;,i-n);    &#125;&#125;</code></pre><h4 id="算法复杂度分析"><a class="header-anchor" href="#算法复杂度分析">¶</a>算法复杂度分析</h4><p>设S,T串的长度分别为n、m。KMP 算法的特点是：i不回退，当S[j]≠T[j]时，j回退<br>到next[j]，重新开始比较。最坏情况下扫描整个S串，其时间复杂度为 O（n)。计算next数<br>组需要扫描整个 工串，其时间复杂度为 0（m），因此总的时间复杂度为 O(n×m)。<br>需要注意的是，尽管 BF 算法最坏情况下时间复杂度为 O（n×m)，KMP 算法的时间复杂<br>度为 O(n×m)。但是在实际运用中，BF 算法的时间复杂度一般为 Q(n×m)，因此仍然有很多<br>地方用 BF 算法进行模式匹配。只有在主串和子串有很多部分匹配的情况下，KMP 才显得更<br>优越</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;几个月前学过一次kmp，因为太愚笨，没有搞明白暂时放弃了，这几天又开始看，终于搞明白了，再次记录一下我的理解😎&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="KMP" scheme="http://example.com/tags/KMP/"/>
    
    <category term="ALGO" scheme="http://example.com/tags/ALGO/"/>
    
  </entry>
  
  <entry>
    <title>vue3</title>
    <link href="http://example.com/2022/08/25/Vue3/"/>
    <id>http://example.com/2022/08/25/Vue3/</id>
    <published>2022-08-25T07:57:50.474Z</published>
    <updated>2022-08-27T12:13:03.755Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下学习vue框架时的知识点以及需要注意的小tips~ 🥰</p><span id="more"></span><h3 id="0-启动vue自带的图形化项目管理界面"><a class="header-anchor" href="#0-启动vue自带的图形化项目管理界面">¶</a>0.  启动<code>vue</code>自带的图形化项目管理界面</h3><p><code>vue ui</code><br>常见问题1：Windows上运行<code>vue</code>，提示无法加载文件，表示用户权限不足。<br>解决方案：用管理员身份打开终端，输入<code>set-ExecutionPolicy RemoteSigned</code>，然后输入<code>y</code></p><h3 id="1-基本概念"><a class="header-anchor" href="#1-基本概念">¶</a>1.   基本概念</h3><h4 id="script部分"><a class="header-anchor" href="#script部分">¶</a>script部分</h4><p><code>export default</code>对象的属性：</p><p><code>name</code>：组件的名称<br><code>components</code>：存储<code>&lt;template&gt;</code>中用到的所有组件<br><code>props</code>：存储父组件传递给子组件的数据<br><code>watch()</code>：当某个数据发生变化时触发<br><code>computed</code>：动态计算某个数据<br><code>setup(props, context)</code>：初始化变量、函数<br><code>ref</code>定义变量，可以用<code>.value</code>属性重新赋值<br><code>reactive</code>定义对象，不可重新赋值<br><code>props</code>存储父组件传递过来的数据<br><code>context.emit()</code>：触发父组件绑定的函数</p><ul><li><code>ref</code>定义变量，可以用.<code>value</code>属性重新赋值</li><li><code>reactive</code>定义对象，不可重新赋值</li><li><code>props</code>存储父组件传递过来的数据</li><li><code>context.emit()</code>：触发父组件绑定的函数</li></ul><h4 id="template部分"><a class="header-anchor" href="#template部分">¶</a>template部分</h4><p><code>&lt;slot&gt;&lt;/slot&gt;</code>：存放父组件传过来的<code>children</code>。<br><code>v-on:click</code>或<code>@click</code>属性：绑定事件<br><code>v-if</code>、<code>v-else</code>、<code>v-else-if</code>属性：判断<br><code>v-for</code>属性：循环，<code>:key</code>循环的每个元素需要有唯一的key<br><code>v-bind:</code>或<code>:：</code>绑定属性</p><h4 id="style部分"><a class="header-anchor" href="#style部分">¶</a>style部分</h4><p><code>&lt;style&gt;</code>标签添加<code>scope</code>属性后，不同组件间的css不会相互影响。</p><h4 id="第三方组件"><a class="header-anchor" href="#第三方组件">¶</a>第三方组件</h4><p><code>view-router</code>包：实现路由功能。<br><code>vuex</code>：存储全局状态，全局唯一。<br><code>state</code>: 存储所有数据，可以用<code>modules</code>属性划分成若干模块<br><code>getters</code>：根据state中的值计算新的值<br><code>mutations</code>：所有对<code>state</code>的修改操作都需要定义在这里，不支持异步，可以通过<code>$store.commit()</code>触发<br><code>actions</code>：定义对<code>state</code>的复杂修改操作，支持异步，可以通过<code>$store.dispatch()</code>触发。注意不能直接修改<code>state</code>，只能通过<code>mutations</code>修改<code>state</code>。<br><code>modules</code>：定义<code>state</code>的子模块</p><h3 id="2-常用API"><a class="header-anchor" href="#2-常用API">¶</a>2. 常用API</h3><h4 id="获取Json-Web-Token（JWT）"><a class="header-anchor" href="#获取Json-Web-Token（JWT）">¶</a>获取Json Web Token（JWT）</h4><ul><li><p>地址：<a href="https://app165.acapp.acwing.com.cn/api/token/">https://app165.acapp.acwing.com.cn/api/token/</a></p></li><li><p>方法：<code>POST</code></p></li><li><p>是否验证jwt：否</p></li><li><p>输入参数：</p><p>​<code>username</code>: 用户名</p><p>​<code>password</code>: 密码</p></li><li><p>返回结果：</p><p>​<code>access</code>: 访问令牌，有效期5分钟</p><p>​<code>refresh</code>: 刷新令牌，有效期14天</p></li></ul><h4 id="刷新JWT令牌"><a class="header-anchor" href="#刷新JWT令牌">¶</a>刷新JWT令牌</h4><ul><li><p>地址：<a href="https://app165.acapp.acwing.com.cn/api/token/refresh/">https://app165.acapp.acwing.com.cn/api/token/refresh/</a></p></li><li><p>方法：<code>POST</code></p></li><li><p>是否验证jwt：否</p></li><li><p>输入参数：</p><p>​<code>refresh</code>: 刷新令牌</p></li><li><p>返回结果：</p><p>​<code>access</code>: 访问令牌，有效期5分钟</p></li></ul><h4 id="获取用户列表"><a class="header-anchor" href="#获取用户列表">¶</a>获取用户列表</h4><ul><li>地址：<a href="https://app165.acapp.acwing.com.cn/myspace/userlist/">https://app165.acapp.acwing.com.cn/myspace/userlist/</a></li><li>方法：<code>GET</code></li><li>是否验证jwt：否</li><li>输入参数：无</li><li>返回结果：返回10个用户的信息</li></ul><h4 id="获取某个用户的信息"><a class="header-anchor" href="#获取某个用户的信息">¶</a>获取某个用户的信息</h4><ul><li><p>地址：<a href="https://app165.acapp.acwing.com.cn/myspace/getinfo/">https://app165.acapp.acwing.com.cn/myspace/getinfo/</a></p><p>​方法：<code>GET</code></p></li><li><p>是否验证jwt：是</p></li><li><p>输入参数：</p><p>​<code>user_id</code>：用户的ID</p></li><li><p>返回结果：该用户的信息</p></li></ul><h4 id="获取某个用户的所有帖子"><a class="header-anchor" href="#获取某个用户的所有帖子">¶</a>获取某个用户的所有帖子</h4><ul><li><p>地址：<a href="https://app165.acapp.acwing.com.cn/myspace/post/">https://app165.acapp.acwing.com.cn/myspace/post/</a></p></li><li><p>方法：<code>GET</code></p></li><li><p>是否验证jwt：是</p></li><li><p>输入参数：</p><p>​<code>user_id</code>：用户的ID</p></li><li><p>返回结果：该用户的所有帖子</p></li></ul><h4 id="创建一个帖子"><a class="header-anchor" href="#创建一个帖子">¶</a>创建一个帖子</h4><ul><li><p>地址：<a href="https://app165.acapp.acwing.com.cn/myspace/post/">https://app165.acapp.acwing.com.cn/myspace/post/</a></p></li><li><p>方法：<code>POST</code></p></li><li><p>是否验证jwt：是</p></li><li><p>输入参数：</p><p>​<code>content</code>：帖子的内容</p></li><li><p>返回结果：<code>result: success</code></p></li></ul><h4 id="删除一个帖子"><a class="header-anchor" href="#删除一个帖子">¶</a>删除一个帖子</h4><ul><li><p>地址：<a href="https://app165.acapp.acwing.com.cn/myspace/post/">https://app165.acapp.acwing.com.cn/myspace/post/</a></p></li><li><p>方法：<code>DELETE</code></p></li><li><p>是否验证jwt：是</p></li><li><p>输入参数：</p><p>​<code>post_id</code>：被删除帖子的ID</p></li><li><p>返回结果：<code>result: success</code></p></li></ul><h4 id="更改关注状态"><a class="header-anchor" href="#更改关注状态">¶</a>更改关注状态</h4><p>如果未关注，则关注；如果已关注，则取消关注。</p><ul><li><p>地址：<a href="https://app165.acapp.acwing.com.cn/myspace/follow/">https://app165.acapp.acwing.com.cn/myspace/follow/</a></p></li><li><p>方法：POST</p></li><li><p>是否验证jwt：是</p></li><li><p>输入参数：</p><p>​<code>target_id</code>: 被关注的用户ID</p></li><li><p>返回结果：<code>result: success</code></p></li></ul><h4 id="注册账号"><a class="header-anchor" href="#注册账号">¶</a>注册账号</h4><ul><li><p>地址：<a href="https://app165.acapp.acwing.com.cn/myspace/user/">https://app165.acapp.acwing.com.cn/myspace/user/</a></p></li><li><p>方法：<code>POST</code></p></li><li><p>是否验证jwt：否</p></li><li><p>输入参数：</p><p>​<code>username</code>: 用户名</p><p>​<code>password</code>：密码</p><p>​<code>password_confirm</code>：确认密码</p></li><li><p>返回结果：</p><p>​<code>result: success</code></p><p>​<code>result: 用户名和密码不能为空</code></p><p>​<code>result: 两个密码不一致</code></p><p>​<code>result: 用户名已存在</code></p></li></ul><h3 id="3-小知识点"><a class="header-anchor" href="#3-小知识点">¶</a>3 .小知识点</h3><ol><li><p>页面与组件之间信息进行交互时，setup里面要写props和context</p><blockquote><p>父组件向子组件传递信息用props，</p><p>子组件向父组件传递信息用context</p></blockquote></li></ol><p>2.所有的循环都需要绑定一个唯一的key属性</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下学习vue框架时的知识点以及需要注意的小tips~ 🥰&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="vue3" scheme="http://example.com/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/08/24/hello-world/"/>
    <id>http://example.com/2022/08/24/hello-world/</id>
    <published>2022-08-24T07:39:20.125Z</published>
    <updated>2022-10-18T01:04:24.247Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a class="header-anchor" href="#Quick-Start">¶</a>Quick Start</h2><h3 id="Create-a-new-post"><a class="header-anchor" href="#Create-a-new-post">¶</a>Create a new post</h3><pre><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a class="header-anchor" href="#Run-server">¶</a>Run server</h3><pre><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a class="header-anchor" href="#Generate-static-files">¶</a>Generate static files</h3><pre><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a class="header-anchor" href="#Deploy-to-remote-sites">¶</a>Deploy to remote sites</h3><pre><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="http://example.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="others" scheme="http://example.com/tags/others/"/>
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
</feed>
